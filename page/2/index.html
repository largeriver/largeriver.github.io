
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>牧云人</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="专注于SELinux for Android, TIOS">
<meta property="og:type" content="website">
<meta property="og:title" content="牧云人">
<meta property="og:url" content="http://blog.andjoin.com/page/2/index.html">
<meta property="og:site_name" content="牧云人">
<meta property="og:description" content="专注于SELinux for Android, TIOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="牧云人">
<meta name="twitter:description" content="专注于SELinux for Android, TIOS">
  
    <link rel="alternative" href="/atom.xml" title="牧云人" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">牧云人</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="blog.andjoin.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-selinux_resources" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/26/selinux_resources/" class="article-date">
  <time datetime="2016-05-26T03:21:49.000Z" itemprop="datePublished">2016-05-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/security/">security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/26/selinux_resources/">SELinux 资源索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h1><ul>
<li><a href="https://source.android.com/devices/tech/security/se-linux.html" target="_blank" rel="external">Android 官方文档</a></li>
<li><a href="http://seandroid.bitbucket.org/index.html" target="_blank" rel="external">bitbucket</a> 提供了SEAndroid未来的发展方向，例如EOps、MMAC、策略注入、可加载更新、中间策略语言</li>
</ul>
<h1 id="Books"><a href="#Books" class="headerlink" title="Books"></a>Books</h1><ul>
<li><strong>The SELinux Notebook&gt;&gt; 4th</strong> :  NSA官方参考手册，包含了SEAndroid的内容</li>
<li><strong>SELinux by Example: Using Security Enhanced Linux</strong> : 比较详细的SELinux例子，有中文译本</li>
<li><strong><a href="https://www.nsa.gov/research/_files/publications/implementing_selinux.pdf" target="_blank" rel="external">Implement SELinux as a LSM</a></strong> ： Stephen Smalley，SELinux的内核实现细节</li>
</ul>
<h1 id="讨论组"><a href="#讨论组" class="headerlink" title="讨论组"></a>讨论组</h1><p>seandroid-list@tycho.nsa.gov</p>
<h1 id="工具箱"><a href="#工具箱" class="headerlink" title="工具箱"></a>工具箱</h1><ul>
<li><a href="https://github.com/seandroid-analytics/seal" target="_blank" rel="external">seal</a><br>SEAndroid现场分析工具，目前非常原始。</li>
<li><a href="https://github.com/TresysTechnology/setools" target="_blank" rel="external">setools4</a><br>图形化的sepolicy开源分析工具，非常强大，比较有特定的功能是：域转换分析、信息流分析、重复规则分析。二次开发也非常容易。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://blog.andjoin.com/2016/05/26/selinux_resources/" data-id="cipdhm0kg000z7ljw3sfrj3q2" class="article-share-link" data-share="baidu" data-title="SELinux 资源索引">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SELinux/">SELinux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-selinux_status_android_LM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/24/selinux_status_android_LM/" class="article-date">
  <time datetime="2016-05-24T03:21:49.000Z" itemprop="datePublished">2016-05-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>►<a class="article-category-link" href="/categories/android/security/">security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/24/selinux_status_android_LM/">【译】AndroidL和AndroidM的SEAndroid状态与展望</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文是在Linux Sercurity Submit 2015 会议中的PPT<a href="http://kernsec.org/files/lss2015/lss2015_selinuxinandroidlollipopandm_smalley.pdf" target="_blank" rel="external">SELinux in Android Lollipop and Marshmallow</a>。</p>
<p>从Android4.4开始，SELinux被应用于保护Android的可信计算基(TCB).</p>
<h1 id="AndroidL"><a href="#AndroidL" class="headerlink" title="AndroidL"></a>AndroidL</h1><h2 id="在AndroidL中，SELinux的状态是："><a href="#在AndroidL中，SELinux的状态是：" class="headerlink" title="在AndroidL中，SELinux的状态是："></a>在AndroidL中，SELinux的状态是：</h2><ul>
<li>所有的系统和应用都是受约束的，包括root守护进程</li>
<li>只有kernel和init进程是“未约束”的。</li>
<li>即使这两个域也不能为所欲为。</li>
</ul>
<h2 id="SELinux是如何保护TCB？"><a href="#SELinux是如何保护TCB？" class="headerlink" title="SELinux是如何保护TCB？"></a>SELinux是如何保护TCB？</h2><ul>
<li>没有进程可以map低端内存，或者访问/deb/{k}/mem</li>
<li>只有init可以设置内核配置和策略</li>
<li>只有recovery可以修改/和/system目录，这两个目录分别代表rootfs和system分区</li>
<li>本地服务只能从/和/system上开始执行。</li>
<li>只有debuggerd可以执行ptrace调用</li>
<li>应用不能写大多数netlink 套接字</li>
<li>应用不能写大多数service 套接字</li>
<li>不容许读取和follow不可信的符号链接。</li>
</ul>
<h2 id="SElinux如何保护系统服务？"><a href="#SElinux如何保护系统服务？" class="headerlink" title="SElinux如何保护系统服务？"></a>SElinux如何保护系统服务？</h2><p>以 负责提供密钥的安全存储的Android KeyStore 为例：</p>
<ul>
<li>SELinux 内核增强防护：<ul>
<li>没有进程可以ptract keystore</li>
<li>没有其他进程可以打开/data/misc/keystore 文件</li>
</ul>
</li>
<li>SELinux 用户空间访问控制：<ul>
<li>敏感操作由selinux策略进行限制</li>
<li>keystore 在客户请求时，检查相应的selinux 策略</li>
</ul>
</li>
</ul>
<h2 id="AndroidL-CTS-of-SELinux"><a href="#AndroidL-CTS-of-SELinux" class="headerlink" title="AndroidL CTS of SELinux"></a>AndroidL CTS of SELinux</h2><p>对于一个正常androidL及更新的版本，其必须要满足的基本原则是：</p>
<ul>
<li>所有的域都处于enforcing状态</li>
<li>只有init运行在init域</li>
<li>只有kernel 线程运行在kernel域</li>
<li>android核心服务运行在各自独立的域中</li>
<li>正常版本中，不应该存在进程运行在su域和recovery域</li>
<li>不支持policy booleans</li>
</ul>
<h1 id="Android-6-0-Marshmallow-“M”"><a href="#Android-6-0-Marshmallow-“M”" class="headerlink" title="Android 6.0 Marshmallow (“M”)"></a>Android 6.0 Marshmallow (“M”)</h1><h2 id="SELinux-新变化"><a href="#SELinux-新变化" class="headerlink" title="SELinux 新变化"></a>SELinux 新变化</h2><ul>
<li>ioctl 白名单支持</li>
<li>增强的android多用户支持</li>
<li>增强的chrome沙箱</li>
<li>Binder 锁定</li>
<li>策略加固</li>
<li>CTS 强化</li>
</ul>
<h2 id="Android-多用户"><a href="#Android-多用户" class="headerlink" title="Android 多用户"></a>Android 多用户</h2><p>Android多用户机制，在Android4.2中引入平板中，从AndroidL中开始支持Phone。Android多用户机制是受控受限配置的基础，如Android for Work。</p>
<h2 id="SELinux和Android-多用户"><a href="#SELinux和Android-多用户" class="headerlink" title="SELinux和Android 多用户"></a>SELinux和Android 多用户</h2><ul>
<li>目标：加强android多用户的透明隔离 而无需复杂的策略</li>
<li>将用户id映射为惟一的MLS级别（mls categories），指派给应用进程和文件</li>
<li>MLS约束将防止不同级别间的通讯（binder中间层除外）</li>
<li>不同的用户的进程自动被赋予不同的级别</li>
<li>SElinux防止跨级别的通信：发送信号，访问/proc/pid,打开应用数据文件，本地socet</li>
<li>无需额外的针对每个用户或者每个应用的策略配置。mls机制搞定一切</li>
</ul>
<h2 id="Chrome沙箱"><a href="#Chrome沙箱" class="headerlink" title="Chrome沙箱"></a>Chrome沙箱</h2><h2 id="BInder锁定-Locking-down"><a href="#BInder锁定-Locking-down" class="headerlink" title="BInder锁定(Locking down)"></a>BInder锁定(Locking down)</h2><h2 id="策略加固"><a href="#策略加固" class="headerlink" title="策略加固"></a>策略加固</h2><ul>
<li>强制init 在exec时进行域转换，所有的服务和辅助程序都运行在独立的域之中</li>
<li>锁定块设备的访问：防止对关键分区的直接访问；限制每个域只能访问必需的分区</li>
<li>移除非受限域：init和kernel 也不是非受限域了。</li>
<li>更多额度neverallow规则</li>
</ul>
<h2 id="CTS-增强"><a href="#CTS-增强" class="headerlink" title="CTS 增强"></a>CTS 增强</h2><h1 id="将来"><a href="#将来" class="headerlink" title="将来"></a>将来</h1><ul>
<li>Enable apps to opt into stronger protections：Sandboxing, isolation, file protection</li>
<li>调查新的运行时权限策略(AndroidM)</li>
<li>改进SELinux工具</li>
<li>未来的用户空间策略增强</li>
<li>内核自保护</li>
</ul>
<p>References:</p>
<ul>
<li>Source code: <a href="https://bitbucket.org/seandroid" target="_blank" rel="external">https://bitbucket.org/seandroid</a></li>
<li>Project page: <a href="http://seandroid.bitbucket.org" target="_blank" rel="external">http://seandroid.bitbucket.org</a></li>
<li>ToDo list: <a href="https://bitbucket.org/seandroid/wiki/wiki/ToDo" target="_blank" rel="external">https://bitbucket.org/seandroid/wiki/wiki/ToDo</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://blog.andjoin.com/2016/05/24/selinux_status_android_LM/" data-id="cipdhm0ki00127ljwxn852ln4" class="article-share-link" data-share="baidu" data-title="【译】AndroidL和AndroidM的SEAndroid状态与展望">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SELinux/">SELinux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/security/">security</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-byod_ultimate_guide_CN" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/25/byod_ultimate_guide_CN/" class="article-date">
  <time datetime="2016-03-25T06:09:52.000Z" itemprop="datePublished">2016-03-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/security/">security</a>►<a class="article-category-link" href="/categories/security/OpenCourse/">OpenCourse</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/25/byod_ultimate_guide_CN/">【译】BYOD终极指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文：<a href="https://www.mobileiron.com/sites/default/files/whitepapers/files/Guide-to-BYOD.pdf" target="_blank" rel="external">《The Ultimate Guide to BYOD》</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>企业拥抱移动技术的速率，不仅仅是一场进化了，而是一次全球性的转换。移动设备和应用的爆炸性的流行，提供了企业一个巨大的机会：成为一个“Mobile Fiest”企业。用户期望在任何地方，在自己的设备上，弹性管理个人和专业事务。然而，安全的，高性价比的使能BYOD的能力，对大多数前瞻性公司是一种挑战。</p>
<p>利用移动性的便利性的同时，也需要保护企业数据和网络资源，这是一种平衡。大多数企业仅仅是简单夸夸其谈，而在具体的政策和闺房上，让IT部门和员工一头雾水。<br>例如：</p>
<ul>
<li>公司应该对员工的设备和内容有多少控制？</li>
<li>谁应该为设备和服务付费？</li>
<li>合理的最终用户协议是什么？</li>
<li>公司应该支持何种设备？</li>
<li>当员工离职时，个人设备上的公司数据将怎么办？</li>
</ul>
<p>本书的目的是：帮助你的企业预测、理解和管理与BYOD相关的问题。</p>
<h1 id="Part1：准备你的企业"><a href="#Part1：准备你的企业" class="headerlink" title="Part1：准备你的企业"></a>Part1：准备你的企业</h1><h2 id="确定你的BYOD风险容忍度"><a href="#确定你的BYOD风险容忍度" class="headerlink" title="确定你的BYOD风险容忍度"></a>确定你的BYOD风险容忍度</h2><p>企业该如何充分利用移动化的业务潜力（business potential）而不危及安全和效率呢？</p>
<p>第一步，BYOD风险容忍度评估，将帮助企业识别和关注相关区域，充分了解公司对员工弹性工作的容忍度，包括：容许的设备、IT参与度和安全策略。这种风险容忍度评估是一个良好的开始：在不牺牲安全和员工满意度的前提下，保证你BYOD Program(方案)支持公司文化和商业目标。</p>
<h2 id="尽早让利益相关者参与定义方案目标"><a href="#尽早让利益相关者参与定义方案目标" class="headerlink" title="尽早让利益相关者参与定义方案目标"></a>尽早让利益相关者参与定义方案目标</h2><p>通常来说，移动用户期望在任何地方，在他们自己选择的设备上，访问他们所需要的工作和个人事务的数据。<br>执行层面的利益相关者的支持是重要的，你还需要了解最终用户的需要和期望，让员工代表参与需求定义。</p>
<p>预测BYOD的公共对象，也能帮助你推进计划阶段。本阶段常见的关注点和回答是这样的：</p>
<ul>
<li>EXECUTIVE SPONSORSHIP<ul>
<li>我们无法获得决策者支持，但让我们继续推进BYOD计划吧</li>
<li>停！BYOD项目需要各个利益相关者的参与。为了保证deadline和responsibilities，决策层的支持非常重要。</li>
</ul>
</li>
<li><p>人力资源</p>
<ul>
<li>如果危及员工个人设备上的私人数据，公司不负责。</li>
<li>合作！HR和IT应该清晰的界定契合和个人数据。同时，你的最终用户协议应该指明：如果司法分析设备时，公司可能访问私人数据。同时，除了需要同公司数据分离，应尽可能保护员工数据上的用户个人数据，但必要时可能全盘清除数据。</li>
</ul>
</li>
<li><p>财务</p>
<ul>
<li>我们不能投资一项不能证明可节省开支的方案。</li>
<li>实际上，利用自助工具、用户支持社区、社交网络和用户论坛，实现用户自助服务，可以减少支持和运营成本。</li>
</ul>
</li>
<li><p>IT人员</p>
<ul>
<li>我们没法在个人设备对大量多变的商业应用提供支持。</li>
<li>对于IOS设备，AppConnect可以无需部署新的应用版本就可以管理应用配置和策略，从而大大降低IT的负担。</li>
</ul>
</li>
</ul>
<h2 id="在雇员中调查"><a href="#在雇员中调查" class="headerlink" title="在雇员中调查"></a>在雇员中调查</h2><ul>
<li>Which OS/devices employees currently own and plan<br>to purchase in the future</li>
<li>Which factors would encourage BYOD participation</li>
<li>Which factors would discourage BYOD participation</li>
<li>Which corporate apps they consider most valuable</li>
<li>Their comfort level with self-service support</li>
<li>The impact of BYOD on company perception, productivity and work/life balance</li>
</ul>
<h1 id="PART-II-BUILD-THE-PROGRAM"><a href="#PART-II-BUILD-THE-PROGRAM" class="headerlink" title="PART II: BUILD THE PROGRAM"></a>PART II: BUILD THE PROGRAM</h1><h2 id="更新你的基础设施以支持BYOD"><a href="#更新你的基础设施以支持BYOD" class="headerlink" title="更新你的基础设施以支持BYOD"></a>更新你的基础设施以支持BYOD</h2><p>管理移动IT设施的所需技能，与管理企业传统的PC设施的技能是大不相同的。下面是构建和运维BYOD所需的几个角色：</p>
<ol>
<li>Mobile System Engineer：熟悉移动技术各个方面的专家，掌握实施BYOD方案所需的所有软件、硬件和网络技术，并将移动技术集成到企业中去。其专业领域包括：1）OS 2）通讯网络 3）移动软硬件、应用、API和开发工具</li>
<li>Mobile Device Expert：熟悉现在和未来的，可影响移动设施的设备、软件。他们为支持和限制用户的新设备而准备环境，熟悉主流平台和制造商。</li>
<li>Mobile Security Expert：负责构建移动安全策略和控制，保持其有效性，必要时进行调整。他们也需要对用户进行安全风险教育，设置合适的用户策略，帮助安全策略的开发：1）移动安全和风险控制 2）移动数据保护 3）移动OS平台评估 4）移动应用威胁管理</li>
<li>Mobile Application Developer</li>
<li>Mobile Service and Support Resources</li>
</ol>
<h2 id="BYOD策略八要素"><a href="#BYOD策略八要素" class="headerlink" title="BYOD策略八要素"></a>BYOD策略八要素</h2><p>BYOD的终极跳帧不仅仅是管理数据安全或者优化最终用户效率。它维护一种常态平衡：安全、合规compliance、法律责任liability、成本和良好的用户体验。成功BYOD方案策略的八要素：</p>
<ul>
<li>SUSTAINABILITY:Maintain a positive user experience</li>
<li>TRUST MODEL：Mitigate security risks</li>
<li>DEVICE CHOICE：It’s a popularity contest</li>
<li>LIABILITY  [ˌlaɪə’bɪləti]    责任：Protect your company from legal action</li>
<li>USER experience &amp; privacy：Establish employee trust</li>
<li>Economics：The cost of doing BYOD</li>
<li>App design and governance：Enforce security without becoming Big Brother</li>
<li>internal marketing： Build your IT “brand”</li>
</ul>
<h1 id="PART-III-ROLL-OUT-THE-PROGRAM"><a href="#PART-III-ROLL-OUT-THE-PROGRAM" class="headerlink" title="PART III: ROLL OUT THE PROGRAM"></a>PART III: ROLL OUT THE PROGRAM</h1><p>软启动你的BYOD方案。在你的方案目标，策略，过程和技术设施建立后，你就可以开始rollout(展开)，也称软启动。你将容许一部分用户测试方案，提出反馈。BYOD方案展开分为三个阶段：</p>
<h2 id="initiate-pilot-tests"><a href="#initiate-pilot-tests" class="headerlink" title="initiate pilot tests."></a>initiate pilot tests.</h2><p>steps:</p>
<pre><code>* Select the sample user group for the pilot
* Survey employees to continually improve the user experience
</code></pre><h2 id="Deploy-the-BYOD-program-and-training-services"><a href="#Deploy-the-BYOD-program-and-training-services" class="headerlink" title="Deploy the BYOD program and training services"></a>Deploy the BYOD program and training services</h2><p>#PART IV: SUSTAIN BYOD SECURITY AND PERFORMANCE</p>
<h1 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h1><p>2014年底，BYOD在你的工作间可能高达%80，以你从没想到的方式改变你的业务。为这种转变做准备，将不仅仅出于安全考虑。 利用人、过程和必要的工具成为Mobile First企业，准备好探索整个新的机遇，这才是BYOD。</p>
<p>本GUIDE是通过成功实施以达成你的移动化的伟大的第一步。不过成功的BYOD依赖于其长期持续性，这意味着保证企业数据的安全、支持员工设备的配置去驱动用户调整、维持一个弹性的技术组合。</p>
<p>BYOD可持续性也依赖于与利益相关者和用户之间有效而开放的沟通。</p>
<p>一句话，成功的BYOD方案要求持续关注和反馈。BYOD已经来到。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://blog.andjoin.com/2016/03/25/byod_ultimate_guide_CN/" data-id="cipdhm0ik00057ljwcinz1tr8" class="article-share-link" data-share="baidu" data-title="【译】BYOD终极指南">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BYOD/">BYOD</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-setools4_sedta" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/26/setools4_sedta/" class="article-date">
  <time datetime="2016-02-26T03:52:33.000Z" itemprop="datePublished">2016-02-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/security/">security</a>►<a class="article-category-link" href="/categories/security/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/26/setools4_sedta/">setools4 sedta 转换图的构建分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>sedta.py</p>
<h1 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h1><p>sedta命令用来分析动态域转换，其基本原理是首先构建域转换图，然后使用路径分析查找 源域和目标域 之间的路径。在apol中，还可以调用networkx等工具来绘图。</p>
<p>本文分析了域转换有向图的构建。</p>
<h2 id="域转换的类型"><a href="#域转换的类型" class="headerlink" title="域转换的类型"></a>域转换的类型</h2><h3 id="Standard-transitions-a-gt-b"><a href="#Standard-transitions-a-gt-b" class="headerlink" title="Standard transitions a-&gt;b:"></a>Standard transitions a-&gt;b:</h3><pre><code># allow a b:process transition;
# allow a b_exec:file execute;
# allow b b_exec:file entrypoint;
#
# and at least one of:
# allow a self:process setexec;
# type_transition a b_exec:process b;
#
</code></pre><p>标准的域转换有两种途径：</p>
<ul>
<li>type_transition: a 在执行b的可执行文件时，自动切换到b域。在SEAndroid中，宏domain_auto_trans 就是属于该种转换。</li>
<li>process setexec: a 本身是selinux-aware的进程，因此主动调用setexec将进程域切换到b。在SEAndroid中，init进程就使用该方式来将子进程切换到新的域。</li>
</ul>
<h3 id="Dynamic-transition-x-gt-y"><a href="#Dynamic-transition-x-gt-y" class="headerlink" title="Dynamic transition x-&gt;y:"></a>Dynamic transition x-&gt;y:</h3><pre><code># allow x y:process dyntransition;
# allow x self:process setcurrent;
</code></pre><p>动态域转换，在SEAndroid中，最常使用该转换的就是zygote进程了。因为zygote启动的apk，不是一个完整的可执行程序，不带有main入口，因此实际的切换过程是：zygote fork一个子进程，调用setcurrent切换到untrusted_app域，然后加载并执行apk里对应的可执行代码入口。</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><ol>
<li>迭代所有的规则<ol>
<li>跳过所有非allow/type_transition规则</li>
<li>如果是process transition/dyntransition规则,那么增加一条边，初始化规则列表，增加此规则</li>
<li>如果是process setexec或者setcurrent，增加到该subject对应的字典中。</li>
<li>如果是file exec/entryppint 或者是type_transition:process，那么将其增加到以（subject，object）为主键的字典中。</li>
</ol>
</li>
<li>遍历所有的边<ol>
<li>如果是transition规则（否则丢到<strong>无效转换表</strong>中）<ol>
<li>使用set intersection来查找匹配的exec和entrypointer规则。如果没有，那么将该边丢到无效转换表中</li>
<li>对每一个有效的entrypoint规则，如果存在相应的type+transition，或者其源域有着setexec权限，那么讲规则增加到边列表。</li>
<li>否则，丢到无效转换表中</li>
</ol>
</li>
<li>如果是dyntransition规则（否则丢到<strong>无效动态转换表中</strong>）<ol>
<li>如果源域存在对应的setcurrent规则，将其增加到边列表；否则，丢到无效动态转换表中</li>
</ol>
</li>
</ol>
</li>
<li>遍历所有的边<ol>
<li>如果一条边存在一条无效转换和无效动态转换，删除该边</li>
<li>如果一条边存在无效转换，清除该边上相应的列表</li>
<li>如果一条边存在无效动态转换，清除该边上相应的列表</li>
</ol>
</li>
</ol>
<h2 id="一些package"><a href="#一些package" class="headerlink" title="一些package"></a>一些package</h2><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><p>代码中，defaultdict取代了常用的dict，defaultdict类的初始化函数接受一个类型作为参数，当所访问的键不存在的时候，可以实例化一个值作为默认值。<br>官方文档的这个例子就能看到这种写法的简洁了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [(<span class="string">'yellow'</span>, <span class="number">1</span>), (<span class="string">'blue'</span>, <span class="number">2</span>), (<span class="string">'yellow'</span>, <span class="number">3</span>), (<span class="string">'blue'</span>, <span class="number">4</span>), (<span class="string">'red'</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = defaultdict(list)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line"><span class="meta">... </span>d[k].append(v)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.items()</span><br><span class="line">[(<span class="string">'blue'</span>, [<span class="number">2</span>, <span class="number">4</span>]), (<span class="string">'red'</span>, [<span class="number">1</span>]), (<span class="string">'yellow'</span>, [<span class="number">1</span>, <span class="number">3</span>])]</span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>当我们做这种带有统计性质的数据操作时候，这个对象很好用。</p>
<h3 id="networkx"><a href="#networkx" class="headerlink" title="networkx"></a>networkx</h3><p>networkX.DiGraph用来存储有向图。 <a href="https://networkx.lanl.gov/" target="_blank" rel="external">NetworkX (NX)</a> is a Python package for the creation, manipulation, and   study of the structure, dynamics, and functions of complex networks.   </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G=nx.Graph()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G.add_edge(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G.add_node(<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sorted(G.nodes()))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">42</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sorted(G.edges()))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">DomainTransitionAnalysis</span><span class="params">(object)</span>:</span>

    <span class="function"><span class="keyword">def</span> <span class="title">_build_graph</span><span class="params">(self)</span>:</span>
        <span class="comment">#初始化图，self.G = nx.DiGraph()</span>
        self.G.clear()
        self.G.name = <span class="string">"Domain transition graph for {0}."</span>.format(self.policy)

        self.log.info(<span class="string">"Building graph from {0}..."</span>.format(self.policy))

        <span class="comment"># hash tables keyed on domain type</span>
        <span class="comment">#   allow a self:process setexec;  type_transition a b_exec:process b;</span>
        <span class="comment">#   allow x y:process dyntransition; allow x self:process setcurrent;</span>
        <span class="comment"># setexec和setcurrent 记录的是source domian能够转换到的target domains 列表</span>
        setexec = defaultdict(list)
        setcurrent = defaultdict(list)

        <span class="comment"># hash tables keyed on (domain, entrypoint file type)</span>
        <span class="comment"># the parameter for defaultdict has to be callable</span>
        <span class="comment"># hence the lambda for the nested defaultdict</span>
        <span class="comment">#</span>
        execute = defaultdict(<span class="keyword">lambda</span>: defaultdict(list))
        entrypoint = defaultdict(<span class="keyword">lambda</span>: defaultdict(list))

        <span class="comment"># hash table keyed on (domain, entrypoint, target domain)</span>
        type_trans = defaultdict(<span class="keyword">lambda</span>: defaultdict(<span class="keyword">lambda</span>: defaultdict(list)))

        <span class="comment"># rule的组成：ruletype source target tclass:perms</span>
        <span class="keyword">for</span> rule <span class="keyword">in</span> self.policy.terules():
            <span class="keyword">if</span> rule.ruletype == <span class="string">"allow"</span>:
                <span class="keyword">if</span> rule.tclass <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">"process"</span>, <span class="string">"file"</span>]:
                    <span class="keyword">continue</span>

                perms = rule.perms

                <span class="keyword">if</span> rule.tclass == <span class="string">"process"</span>:
                    <span class="keyword">if</span> <span class="string">"transition"</span> <span class="keyword">in</span> perms:
                        <span class="keyword">for</span> s, t <span class="keyword">in</span> itertools.product(rule.source.expand(), rule.target.expand()):
                            <span class="comment"># only add edges if they actually</span>
                            <span class="comment"># transition to a new type</span>
                            <span class="keyword">if</span> s != t:
                                edge = Edge(self.G, s, t, create=<span class="keyword">True</span>)
                                edge.transition.append(rule)

                    <span class="keyword">if</span> <span class="string">"dyntransition"</span> <span class="keyword">in</span> perms:
                        <span class="keyword">for</span> s, t <span class="keyword">in</span> itertools.product(rule.source.expand(), rule.target.expand()):
                            <span class="comment"># only add edges if they actually</span>
                            <span class="comment"># transition to a new type</span>
                            <span class="keyword">if</span> s != t:
                                e = Edge(self.G, s, t, create=<span class="keyword">True</span>)
                                e.dyntransition.append(rule)

                    <span class="keyword">if</span> <span class="string">"setexec"</span> <span class="keyword">in</span> perms:
                        <span class="keyword">for</span> s <span class="keyword">in</span> rule.source.expand():
                            setexec[s].append(rule)

                    <span class="keyword">if</span> <span class="string">"setcurrent"</span> <span class="keyword">in</span> perms:
                        <span class="keyword">for</span> s <span class="keyword">in</span> rule.source.expand():
                            setcurrent[s].append(rule)

                <span class="keyword">else</span>:
                    <span class="keyword">if</span> <span class="string">"execute"</span> <span class="keyword">in</span> perms:
                        <span class="keyword">for</span> s, t <span class="keyword">in</span> itertools.product(
                                rule.source.expand(),
                                rule.target.expand()):
                            execute[s][t].append(rule)

                    <span class="keyword">if</span> <span class="string">"entrypoint"</span> <span class="keyword">in</span> perms:
                        <span class="keyword">for</span> s, t <span class="keyword">in</span> itertools.product(rule.source.expand(), rule.target.expand()):
                            entrypoint[s][t].append(rule)

            <span class="keyword">elif</span> rule.ruletype == <span class="string">"type_transition"</span>:
                <span class="keyword">if</span> rule.tclass != <span class="string">"process"</span>:
                    <span class="keyword">continue</span>

                d = rule.default
                <span class="keyword">for</span> s, t <span class="keyword">in</span> itertools.product(rule.source.expand(), rule.target.expand()):
                    type_trans[s][t][d].append(rule)

        invalid_edge = []
        clear_transition = []
        clear_dyntransition = []

        <span class="keyword">for</span> s, t <span class="keyword">in</span> self.G.edges_iter():
            edge = Edge(self.G, s, t)
            invalid_trans = <span class="keyword">False</span>
            invalid_dyntrans = <span class="keyword">False</span>

            <span class="keyword">if</span> edge.transition:
                <span class="comment"># get matching domain exec w/entrypoint type</span>
                entry = set(entrypoint[t].keys())
                exe = set(execute[s].keys())
                match = entry.intersection(exe)

                <span class="keyword">if</span> <span class="keyword">not</span> match:
                    <span class="comment"># there are no valid entrypoints</span>
                    invalid_trans = <span class="keyword">True</span>
                <span class="keyword">else</span>:
                    <span class="comment"># TODO try to improve the</span>
                    <span class="comment"># efficiency in this loop</span>
                    <span class="keyword">for</span> m <span class="keyword">in</span> match:
                        <span class="keyword">if</span> s <span class="keyword">in</span> setexec <span class="keyword">or</span> type_trans[s][m]:
                            <span class="comment"># add key for each entrypoint</span>
                            edge.entrypoint[m] += entrypoint[t][m]
                            edge.execute[m] += execute[s][m]

                        <span class="keyword">if</span> type_trans[s][m][t]:
                            edge.type_transition[m] += type_trans[s][m][t]

                    <span class="keyword">if</span> s <span class="keyword">in</span> setexec:
                        edge.setexec.extend(setexec[s])

                    <span class="keyword">if</span> <span class="keyword">not</span> edge.setexec <span class="keyword">and</span> <span class="keyword">not</span> edge.type_transition:
                        invalid_trans = <span class="keyword">True</span>
            <span class="keyword">else</span>:
                invalid_trans = <span class="keyword">True</span>

            <span class="keyword">if</span> edge.dyntransition:
                <span class="keyword">if</span> s <span class="keyword">in</span> setcurrent:
                    edge.setcurrent.extend(setcurrent[s])
                <span class="keyword">else</span>:
                    invalid_dyntrans = <span class="keyword">True</span>
            <span class="keyword">else</span>:
                invalid_dyntrans = <span class="keyword">True</span>

            <span class="comment"># cannot change the edges while iterating over them,</span>
            <span class="comment"># so keep appropriate lists</span>
            <span class="keyword">if</span> invalid_trans <span class="keyword">and</span> invalid_dyntrans:
                invalid_edge.append(edge)
            <span class="keyword">elif</span> invalid_trans:
                clear_transition.append(edge)
            <span class="keyword">elif</span> invalid_dyntrans:
                clear_dyntransition.append(edge)

        <span class="comment"># Remove invalid transitions</span>
        self.G.remove_edges_from(invalid_edge)
        <span class="keyword">for</span> edge <span class="keyword">in</span> clear_transition:
            <span class="comment"># if only the regular transition is invalid,</span>
            <span class="comment"># clear the relevant lists</span>
            <span class="keyword">del</span> edge.transition
            <span class="keyword">del</span> edge.execute
            <span class="keyword">del</span> edge.entrypoint
            <span class="keyword">del</span> edge.type_transition
            <span class="keyword">del</span> edge.setexec
        <span class="keyword">for</span> edge <span class="keyword">in</span> clear_dyntransition:
            <span class="comment"># if only the dynamic transition is invalid,</span>
            <span class="comment"># clear the relevant lists</span>
            <span class="keyword">del</span> edge.dyntransition
            <span class="keyword">del</span> edge.setcurrent

        self.rebuildgraph = <span class="keyword">False</span>
        self.rebuildsubgraph = <span class="keyword">True</span>
        self.log.info(<span class="string">"Completed building graph."</span>)
</code></pre>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://blog.andjoin.com/2016/02/26/setools4_sedta/" data-id="cipdhm0kz00197ljw3bswtn3r" class="article-share-link" data-share="baidu" data-title="setools4 sedta 转换图的构建分析">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SELinux/">SELinux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/setools4/">setools4</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android_graphic_system" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/01/android_graphic_system/" class="article-date">
  <time datetime="2015-07-01T02:13:49.000Z" itemprop="datePublished">2015-07-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/01/android_graphic_system/">[摘]Android 图形系统 （Android 4.3）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文摘自 《深入理解Android设计思想》</p>
<p>在Android4.3之前的版本中，最终的显示工作是要交给FrameBuffer的，而从4.3开始，合成工作由SurfaceFlinger交给硬件合成器来完成，显示工作将由硬件合成器HAL来完成。<br>参考链接：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954508" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954508</a></p>
<h1 id="OpenGL-ES与EGL"><a href="#OpenGL-ES与EGL" class="headerlink" title="OpenGL ES与EGL"></a>OpenGL ES与EGL</h1><p><strong>SurfaceFlinger</strong>虽然是GUI的核心，但相对于OpenGL ES来讲，它其实<strong>只是一个“应用”</strong>。</p>
<p><img src="/img/android_graphic_system_01.png" alt=""><br>我们根据上面这个图，由底层往上层来逐步分析整个架构：</p>
<ol>
<li>Linux内核提供了统一的framebuffer显示驱动，设备节点/dev/graphics/fb<em>或者/dev/fb</em>，以fb0表示第一个Monitor，当前实现中只用到了一个显示屏</li>
<li><p>Android的HAL层提供了Gralloc，分为fb和gralloc两个设备。</p>
<ul>
<li><strong>fb 负责内核中framebuffer</strong>的打开、初始化配置，以及提供post、setSwapInterval等操作</li>
<li><strong>Gralloc 则管理帧缓冲区的分配和释放</strong>。上层只能通过Gralloc访问帧缓冲区，这样一来就实现了有序的封装保护</li>
</ul>
</li>
<li><p>由于<strong>OpenGL ES是一个通用的函数库</strong>，在不同的平台系统上需要被“本地化”——即把它与具体平台上的窗口系统建立起关联，这样才能保证它正常工作。从FramebufferNativeWindow这个名称就能判断出来，它就是将OpenGL ES在Android平台上本地化的中介之一。后面我们还会看到应用程序端所使用的另一个“本地窗口”。为OpengGL ES配置本地窗口的是EGL</p>
</li>
<li><strong>OpenGL或者OpenGL ES 更多的只是一个接口协议，实现上既可以采用软件，也能依托于硬件。</strong>这一方面给产品开发带来了灵活性，我们可以根据成本与市场定位来决定具体的硬件设计，从而达到很好的定制需求;另一方面，既然有多种实现的可能，那么OpenGL ES在运行时是如何取舍的呢？这也是EGL的作用之一。它会去读取egl.cfg这个配置文件，然后根据用户的设定来动态加载libagl(软件实现)或者libhgl(硬件实现)。然后上层才可以正常使用各种glXXX接口</li>
<li><p>SurfaceFlinger中持有一个GraphicPlane成员变量mGraphicPlanes来描述“显示屏”;GraphicPlane类中又包含了一个DisplayHardware对象实例(mHw)。具体是在SurfaceFlinger::readyToRun中，完成对它们的创建与初始化。并且DisplayHardware在初始化时还将调用eglInitialize、eglCreateWindowSurface等接口，利用EGL来完成对OpenGLES环境的搭建。其中:</p>
<pre><code>surface =**eglCreateWindowSurface**(display, config, mNativeWindow.get(), NULL);
</code></pre><p>mNativeWindow 就是一个FramebufferNativeWindow对象。DisplayHardware为OpenGL ES设置了“本地化”所需的窗口</p>
</li>
<li><p>很多模块都可以调用OpenGLES提供的API(这些接口以“gl”为前缀，比如glViewport、glClear、glMatrixMode、glLoadIdentity等等)，包括SurfaceFlinger、DisplayHardware等</p>
</li>
<li><p>与OpenGL ES相关的模块，可以分为如下几类：</p>
<ul>
<li>配置类  即帮助OpenGL ES完成配置的，包括<strong>EGL</strong>、DisplayHardware都可以认为是这一类</li>
<li>依赖类  也就是OpenGL ES要正常运行起来所依赖的“本地化”的东西，上图中是指FramebufferNativeWindow</li>
<li>使用类  使用者也可能是配置者，比如DisplayHardware既扮演了“帮助”OpenGL的角色，同时它也是其使用方。另外只要处在与OpenGL ES同一个环境(Context)中的模块，都可以使用它来完成操作，比如SurfaceFlinger</li>
</ul>
</li>
</ol>
<h1 id="Gralloc与Framebuffer"><a href="#Gralloc与Framebuffer" class="headerlink" title="Gralloc与Framebuffer"></a>Gralloc与Framebuffer</h1><h2 id="Gralloc库的加载"><a href="#Gralloc库的加载" class="headerlink" title="Gralloc库的加载"></a>Gralloc库的加载</h2><p>Gralloc对应的模块是由<strong>FramebufferNativeWindow</strong>(OpenGLES的本地窗口之一，后面小节有详细介绍)在构造时加载的：</p>
<pre><code>hw_get_module(HWC_HARDWARE_MODULE_ID, &amp;mModule);
</code></pre><p>这个<strong>hw_get_module</strong>函数我们在前面已经见过很多次了，它是上层加载HAL库的入口，这里传入的模块ID名为：</p>
<pre><code>#define GRALLOC_HARDWARE_MODULE_ID  &quot;gralloc&quot;
</code></pre><p>按照hw_get_module的作法，它会在如下路径中查找与ID值匹配的库：</p>
<pre><code>#define HAL_LIBRARY_PATH1 &quot;/system/lib/hw&quot;
#define HAL_LIBRARY_PATH2 &quot;/vendor/lib/hw&quot;
</code></pre><p>Gralloc对应的 lib库名有如下几种形式：</p>
<pre><code>gralloc.[ro.hardware].so
gralloc.[ro.product.board].so
gralloc.[ro.board.platform].so
gralloc.[ro.arch].so
</code></pre><p>或者当上述的系统属性组成的文件名都不存在时，就使用默认的：</p>
<pre><code>gralloc.default.so
</code></pre><p>最后这个库是Android原生态的实现，位置在hardware/libhardware/modules/gralloc/中，它由gralloc.cpp、framebuffer.cpp和mapper.cpp三个主要源文件编译生成。</p>
<h2 id="Gralloc提供的接口"><a href="#Gralloc提供的接口" class="headerlink" title="Gralloc提供的接口"></a>Gralloc提供的接口</h2><p>Gralloc实际操作了两个设备：</p>
<ul>
<li>fb0 就是我们前面说的主屏幕，</li>
<li>gpu0负责图形缓冲区的分配和释放。<br><img src="/img/android_graphic_system_02.png" alt=""></li>
</ul>
<h1 id="本地窗口"><a href="#本地窗口" class="headerlink" title="本地窗口"></a>本地窗口</h1><p><a href="http://blog.csdn.net/xuesen_lin/article/details/8954748" target="_blank" rel="external">原文</a></p>
<p>在OpenGL的学习过程中，我们不断提及“本地窗口”(NativeWindow)这一概念。那么对于Android系统来说，它是如何将OpenGL ES本地化的呢，或者说，它提供了什么样的本地窗口？<br>根据整个Android系统的GUI设计理念，我们不难猜想到至少需要两种本地窗口：</p>
<ol>
<li>面向管理者(SurfaceFlinger) 。既然SurfaceFlinger扮演了系统中所有UI界面的管理者，那么它无可厚非地需要直接或间接地持有“本地窗口”。从前一小节我们已经知道，这个窗口就是<strong>FramebufferNativeWindow</strong>。</li>
<li>面向应用程序。我们先给出答案，这类窗口是<strong>SurfaceTextureClient</strong></li>
</ol>
<h2 id="为什么需要两种窗口系统"><a href="#为什么需要两种窗口系统" class="headerlink" title="为什么需要两种窗口系统"></a>为什么需要两种窗口系统</h2><h3 id="理想的窗口系统"><a href="#理想的窗口系统" class="headerlink" title="理想的窗口系统"></a>理想的窗口系统</h3><p><img src="/img/android_graphic_system_03.png" alt=""><br>理想的窗口系统</p>
<p>假如整个系统仅有一个需要显示UI的程序，我们有理由相信它是可以胜任的。但是如果有N个UI程序的情况呢？Framebuffer显然只有一个，不可能让各个应用程序自己单独管理。</p>
<h3 id="改进的窗口系统"><a href="#改进的窗口系统" class="headerlink" title="改进的窗口系统"></a>改进的窗口系统</h3><p><img src="/img/android_graphic_system_04.png" alt=""><br>改进的窗口系统</p>
<p>在这个改进的窗口系统中，我们有了两类本地窗口，即Window-1和Window-2。</p>
<ol>
<li><strong>第一种窗口</strong>是能直接显示在终端屏幕上的——它<strong>使用了帧缓冲区</strong>，</li>
<li>而<strong>后一种Window实际上是从内存缓冲区分配的空间</strong>。</li>
</ol>
<p>当系统中存在多个应用程序时，这能保证它们都可以获得一个“本地窗口”，并且这些窗口最终也能显示到屏幕上——SurfaceFlinger会收集所有程序的显示需求，对它们做统一的图像混合操作(有点类似于AudioFlinger)，然后输出到自己的Window-1上。<br>当然，这个改进的窗口系统有一个前提，即应用程序与SurfaceFlinger都是基于OpenGL ES来实现的。有没有其它选择呢？答案是肯定的，比如<strong>应用程序端完全可以采用Skia等第三方的图形库，只要保持它们与SurfaceFlinger间的“协议”不变就可以了</strong>，如下所示：</p>
<p><img src="/img/android_graphic_system_05.png" alt=""></p>
<p>理论上来说，采用哪一种方式都是可行的。不过对于开发人员，特别是没有OpenGLES项目经验的人而言，前一种系统的门槛相对较高。事实上，Android系统同时提供了这两种实现来供上层选择。正常情况下我们按照SDK向导生成的apk应用，就属于后面的情况;而对于希望使用OpenGLES来完成复杂的界面渲染的应用开发者，也可以使用GLSurfaceView来达到目标。</p>
<p><img src="/img/android_graphic_system_06.png" alt=""><br>Canvas为在画布的意思。Android上层的作图几乎都通过Canvas实例来完成，其实Canvas更多是一种接口的包装。</p>
<h2 id="FramebufferNativeWindow（面向SurfaceFlinger）"><a href="#FramebufferNativeWindow（面向SurfaceFlinger）" class="headerlink" title="FramebufferNativeWindow（面向SurfaceFlinger）"></a>FramebufferNativeWindow（面向SurfaceFlinger）</h2><p>EGL创建一个Window Surface的函数原型列出如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  EGLNativeWindowType  NativeWindowType;<span class="comment">//注意这两种类型其实是一样的</span></span><br><span class="line"><span class="keyword">struct</span> ANativeWindow;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ANativeWindow*          EGLNativeWindowType;</span><br><span class="line"></span><br><span class="line"><span class="function">EGLSurface <span class="title">eglCreateWindowSurface</span><span class="params">(  EGLDisplay dpy, EGLConfig config,</span><br><span class="line">                          NativeWindowType  window, <span class="keyword">const</span> EGLint *attrib_list)</span></span>;</span><br></pre></td></tr></table></figure>
<p>表格 11‑2 不同平台下的EGLNativeWindowType<br>|操作系统|数据类型|<br>|——|——|<br>|Win32, WinCE|HWND，即句柄|<br>|Symbian|Void<em>|<br>|Android|ANativeWindow</em>          |<br>|Unix|Window|<br>|其它|暂时不支持|</p>
<p>在Android平台下，ANativeWindow指针类型就是OpenGL接口中的windows surface类型。</p>
<h3 id="ANativeWindow的定义"><a href="#ANativeWindow的定义" class="headerlink" title="ANativeWindow的定义"></a>ANativeWindow的定义</h3><p>ANativeWindow的定义在Window.h中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*system/core/include/system/Window.h*/</span></span><br><span class="line"><span class="keyword">struct</span> ANativeWindow</span><br><span class="line">&#123;…</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> flags; <span class="comment">//与Surface或updater有关的属性</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>   minSwapInterval;<span class="comment">//所支持的最小交换间隔时间</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>   maxSwapInterval;<span class="comment">//所支持的最大交换间隔时间</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> xdpi; <span class="comment">//水平方向的密度，以dpi为单位</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> ydpi;<span class="comment">//垂直方向的密度，以dpi为单位</span></span><br><span class="line">    <span class="keyword">intptr_t</span>    oem[<span class="number">4</span>];<span class="comment">//为OEM定制驱动所保留的空间</span></span><br><span class="line">    <span class="comment">//设置交换间隔时间，后面我们会讲解swap的作用</span></span><br><span class="line">    <span class="keyword">int</span>     (*setSwapInterval)(<span class="keyword">struct</span> ANativeWindow*window, <span class="keyword">int</span> interval);</span><br><span class="line">    <span class="comment">/*EGL通过这个接口来申请一个buffer。</span><br><span class="line">    以前面我们所举的例子来说，两个本地窗口所提供的buffer分别来自于帧缓冲区和内存空间。</span><br><span class="line">    单词“dequeue”的字面意思是“出队列”，这从侧面告诉我们，一个Window所包含的buffer很可能不只一份</span><br><span class="line">    */</span></span><br><span class="line">    <span class="keyword">int</span>     (*dequeueBuffer)(<span class="keyword">struct</span> ANativeWindow*window, <span class="keyword">struct</span> ANativeWindowBuffer** buffer);</span><br><span class="line">    <span class="comment">//申请到的buffer并没有被锁定，这种情况下是不允许我们去修改其中的内容的。所以我们必须要先调用lockBuffer来获得一个锁</span></span><br><span class="line">    <span class="keyword">int</span>     (*lockBuffer)(<span class="keyword">struct</span> ANativeWindow*window, <span class="keyword">struct</span> ANativeWindowBuffer* buffer);</span><br><span class="line">    <span class="comment">//当EGL对一块buffer渲染完成后，它调用这个接口来unlock和post buffer  </span></span><br><span class="line">    <span class="keyword">int</span>    (*queueBuffer)(<span class="keyword">struct</span> ANativeWindow* window, <span class="keyword">struct</span> ANativeWindowBuffer*buffer);</span><br><span class="line">    <span class="comment">//用于向本地窗口咨询相关信息</span></span><br><span class="line">    <span class="keyword">int</span>     (*query)(<span class="keyword">const</span> <span class="keyword">struct</span> ANativeWindow*window, <span class="keyword">int</span> what, <span class="keyword">int</span>* value);</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    用于执行本地窗口支持的各种操作，比如：</span><br><span class="line">	NATIVE_WINDOW_SET_USAGE</span><br><span class="line">	NATIVE_WINDOW_SET_CROP</span><br><span class="line">	NATIVE_WINDOW_SET_BUFFER_COUNT</span><br><span class="line">	NATIVE_WINDOW_SET_BUFFERS_TRANSFORM</span><br><span class="line">	NATIVE_WINDOW_SET_BUFFERS_TIMESTAMP</span><br><span class="line">    */</span></span><br><span class="line">    <span class="keyword">int</span>     (*perform)(<span class="keyword">struct</span> ANativeWindow* window,<span class="keyword">int</span> operation, ... );</span><br><span class="line">    <span class="comment">//这个接口可以用来取消一个已经dequeued的buffer，要特别注意同步的问题</span></span><br><span class="line">    <span class="keyword">int</span>     (*cancelBuffer)(<span class="keyword">struct</span> ANativeWindow*window, <span class="keyword">struct</span> ANativeWindowBuffer* buffer);</span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面对ANativeWindow的描述可以看出，它更像是一份“协议”，规定了一个本地窗口的形态和功能。这对于支持多种本地窗口的系统是必须的，因为只有这样子我们才能针对某种特定的平台窗口，来填充具体的实现。<br>FramebufferNativeWindow是如何履行这份“协议”的。</p>
<h3 id="FramebufferNativeWindow构造函数"><a href="#FramebufferNativeWindow构造函数" class="headerlink" title="FramebufferNativeWindow构造函数"></a>FramebufferNativeWindow构造函数</h3><p>基于FramebufferNativeWindow的功能，可以大概推测出它的构造函数里应该至少完成如下的初始化操作：</p>
<ul>
<li>加载GRALLOC_HARDWARE_MODULE_ID模块，详细流程我们在Gralloc小节已经解释过了</li>
<li>分别打开fb和gralloc设备。我们在Gralloc小节也已经分析过了，打开后的设备由全局变量fbDev和grDev管理</li>
<li>根据设备的属性来给FramebufferNativeWindow赋初值</li>
<li>根据FramebufferNativeWindow的实现来填充ANativeWindow中的“协议”</li>
<li>其它一些必要的初始化</li>
</ul>
<h3 id="dequeueBuffer"><a href="#dequeueBuffer" class="headerlink" title="dequeueBuffer"></a>dequeueBuffer</h3><p>。。。</p>
<h2 id="SurfaceTextureClient（面向应用）"><a href="#SurfaceTextureClient（面向应用）" class="headerlink" title="SurfaceTextureClient（面向应用）"></a>SurfaceTextureClient（面向应用）</h2><p>针对<strong>应用程序端的本地窗口</strong>是<strong>SurfaceTextureClient</strong>，和FramebufferNativeWindow一样，它必须继承ANativeWindow：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SurfaceTextureClient : <span class="keyword">public</span> ANativeObjectBase&lt;ANativeWindow, SurfaceTextureClient,RefBase&gt;</span><br></pre></td></tr></table></figure>
<p>SurfaceTextureClient的构造函数只是简单地调用了init函数，后者则对ANativeWindow::dequeueBuffer等函数指针及内部变量赋了初值。由于整个函数的功能很简单，我们只摘录其中的一部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/native/libs/gui/SurfaceTextureClient.cpp*/</span></span><br><span class="line"><span class="keyword">void</span> SurfaceTextureClient::init() &#123;</span><br><span class="line">    <span class="comment">/*给ANativeWindow中的函数指针赋值*/</span></span><br><span class="line">   ANativeWindow::setSwapInterval  =hook_setSwapInterval;</span><br><span class="line">    ANativeWindow::dequeueBuffer    = hook_dequeueBuffer;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">/*为各内部变量赋值，因为此时用户还没有真正发起申请，所以基本是0*/</span></span><br><span class="line">    mReqWidth = <span class="number">0</span>;</span><br><span class="line">    mReqHeight = <span class="number">0</span>;</span><br><span class="line">    …</span><br><span class="line">    mDefaultWidth = <span class="number">0</span>;</span><br><span class="line">    mDefaultHeight = <span class="number">0</span>;</span><br><span class="line">    mUserWidth = <span class="number">0</span>;</span><br><span class="line">    mUserHeight = <span class="number">0</span>;…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SurfaceTextureClient是面向Android系统中所有UI应用程序的，也就是说它承担着单个应用进程中的UI显示需求。基于这点考虑，可以推测出它的内部实现至少会有以下几点：</p>
<ul>
<li>提供给上层(主要是java层)绘制图像的“画板”<br>前面说过，这个本地窗口分配的内存应该不是来自于帧缓冲区，那么具体是由谁分配的，又是如何管理的呢？</li>
<li>它与SurfaceFlinger间是如何分工的?<br>显然SurfaceFlinger需要收集系统中所有应用程序绘制的图像数据，然后集中显示到物理屏幕上。在这个过程中，SurfaceTextureClient扮演了什么样的角色呢？</li>
</ul>
<p>SurfaceTextureClient只是一个中介，它间接调用mSurfaceTexture也就是ISurfaceTexture的服务。那么ISurfaceTexture在Server端又是由谁来完成的呢？</p>
<p><img src="/img/android_graphic_system_07.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过这两个小节，我们学习了显示系统中两个重要的本地窗口，即FramebufferNativewindow和SurfaceTextureClient。</p>
<ol>
<li>第一个窗口是专门为SurfaceFlinger服务的，它由Gralloc提供支持，相对逻辑上很好理解。</li>
<li>而SurfaceTextureClient则是为应用程序服务的，同时它从本质上还是由SurfaceFlinger服务统一管理的，因而涉及到很多跨进程的通信细节。</li>
</ol>
<p>这个小节我们只是简单地勾勒出其中的框架，接下去就要分几个方面来做完整的分析了。</p>
<ul>
<li><p>BufferQueue<br>为应用程序服务的本地窗口SurfaceTextureClient在server端的实现是BufferQueue。我们将详细解析BufferQueue的内部实现，并结合应用程序端的使用流程来理解清楚它们之间的关系。</p>
</li>
<li><p>Buffer、Consumer、Producer是“生产者-消费者”模型中的三个参与对象，如何协调好它们的工作是应用程序能否正常显示UI的关键。在接下来内容的安排上，我们先讲解Buffer(BufferQueue)与Producer(应用程序)间的交互，然后再专门切入Consumer(SurfaceFlinger)做详细分析</p>
</li>
</ul>
<h1 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h1><p>原文：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954803" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954803</a></p>
<p>BufferQueue，它是SurfaceTextureClient实现本地窗口的关键。从逻辑上来推断，BufferQueue应该是驻留在SurfaceFlinger这边的进程中。我们需要进一步解决的疑惑是：</p>
<ul>
<li>每个应用程序可以对应几个BufferQueue，它们是一对一、多对一或者是一对多？</li>
<li>应用程序所需要的绘图空间是由谁分配的？在音频系统的学习中，我们知道AudioTrack和AudioFlinger是通过共享内存的形式来进行数据传递的，那么显示系统中是否也是类似情况？</li>
<li>应用程序与SurfaceFlinger如何互斥共享数据区？和在Audio系统中遇到的问题一样，我们面临的是经典的“生产者-消费者”模型。显示系统又是如何协调好这两者间的互斥访问的呢？</li>
</ul>
<h2 id="BufferQueue的内部原理"><a href="#BufferQueue的内部原理" class="headerlink" title="BufferQueue的内部原理"></a>BufferQueue的内部原理</h2><p>因为BufferQueue是ISurfaceTexture的本地实现，所以它必须重载接口中的各虚函数，比如queueBuffer、requestBuffer、dequeueBuffer等等。</p>
<p><img src="/img/android_graphic_system_08.png" alt=""></p>
<p>另外，这个类的内部有一个非常重要的成员数组，即mSlots[NUM_BUFFER_SLOTS]，大家是否还记得前面SurfaceTextureClient类中也有一个一模一样的数组：</p>
<pre><code>class SurfaceTextureClient…{
                BufferSlot  mSlots[NUM_BUFFER_SLOTS];
</code></pre><p>数组的成员是BufferSlot，其中包含的GraphicBuffer变量(mGraphicBuffer)用于记录这个Slot所涉及的缓冲区，另外还有一个BufferState变量mBufferState用于跟踪每个缓冲区的状态，比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BufferState &#123;</span><br><span class="line">    FREE = <span class="number">0</span>, <span class="comment">/*Buffer当前可用，也就是说可以被dequeued。此时Buffer的owner</span><br><span class="line">               可认为是BufferQueue*/</span></span><br><span class="line">    DEQUEUED = <span class="number">1</span>, <span class="comment">/*Buffer已经被dequeued，还未被queued或canceld。此时</span><br><span class="line">                  Buffer的owner可认为是producer(应用程序)，这意味着server</span><br><span class="line">                  端(BufferQueue)不可以对这块缓冲区进行操作*/</span></span><br><span class="line">    QUEUED = <span class="number">2</span>, <span class="comment">/*Buffer已经被客户端queued，除特别情况外此时还不能对它进</span><br><span class="line">                  行dequeue，而可以acquired。此时的owner是BufferQueue*/</span></span><br><span class="line">    ACQUIRED = <span class="number">3</span><span class="comment">/*Buffer的owner改为consumer，可以released，</span><br><span class="line">                   然后状态又返回FREE*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Buffer状态迁移图如下：<br><img src="/img/android_graphic_system_09.png" alt=""></p>
<p>在这样的模型下，我们怎么保证Consumer可以及时的处理buffer呢？换句话说，当一块buffer数据ready后，应该怎么告知Consumer来操作呢？<br>仔细观察的话，可以看到BufferQueue里还同时提供了一个特别的类，名称为ConsumerListener，其中的函数接口包括：</p>
<pre><code>struct ConsumerListener :public virtual RefBase {       
    virtual void onFrameAvailable() = 0;/*当一块buffer可以被消费时，这个函数会被调用，特别注意此
                                    时没有共享锁的保护*/
    virtual void onBuffersReleased() = 0;/*BufferQueue通知consumer它已经释放其slot中的一个或多个
                                   GraphicBuffer引用*/
};
</code></pre><p> 这样子就很清楚了，当有一帧数据准备就绪后，BufferQueue就会调用<strong>onFrameAvailable</strong>()来通知Consumer进行消费。</p>
<h2 id="BufferQueue中的缓冲区分配"><a href="#BufferQueue中的缓冲区分配" class="headerlink" title="BufferQueue中的缓冲区分配"></a>BufferQueue中的缓冲区分配</h2><p>原文：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954834" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954834</a></p>
<p>当客户端 调用SurfaceTextureClient::dequeueBuffer()时，会导致SurfaceFlinger在BufferQueue中分配缓冲。</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>BufferQueue中有一个mSlots数组用于管理其内的各缓冲区，最大容量为32。从它的声明方式来看，这个mSlots在程序一开始就静态分配了32个BufferSlot大小的空间。不过这并不代表缓冲区也是一次性静态分配的，恰恰相反，从BufferSlot的内部变量指针mGraphicBuffer可以看出，<strong>缓冲区的空间分配应当是动态的</strong>(从下面的注释也能看出一些端倪)：</p>
<pre><code>// mGraphicBuffer points to the buffer allocated for this slot or isNULL if no buffer has been allocated.
       sp&lt;GraphicBuffer&gt; mGraphicBuffer;
</code></pre><p>缓冲区的分配在BufferQueue::dequeueBuffer()中进行。</p>
<pre><code>`status_t BufferQueue::dequeueBuffer(int *outBuf, uint32_t w,uint32_t h, uint32_t format, uint32_t usage)`
</code></pre><p>在该函数中，首先查找空闲的slot序号，但并不代表可用。当第一次使用该slot时，或者长宽高格式等信息不匹配时，其返回值中将加上标识BUFFER_NEEDS_REALLOCATION，表示需要分配内存。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>在客户端SurfaceTextureClient::dequeueBuffer()中的实现中可以发现：</p>
<ol>
<li>当mSurfaceTexture-&gt;dequeueBuffer()成功返回后，buf包含了mSlots中可用数组成员的序号。</li>
<li>如果结果中还发现BUFFER_NEEDS_REALLOCATION标志后，应该调用requestBuffer（）来分配内存。</li>
<li>然后，通过  <code>sp&lt;GraphicBuffer&gt;&amp; gbuf；*buffer = gbuf.get();</code> 来获取mSlots[buf]在本进程的地址。</li>
</ol>
<p>但一个很显然的问题是，既然客户端和BufferQueue运行于两个不同的进程中，那么它们两者中的mSlots[buf]会指向同一块物理内存吗？<br>SurfaceFlinger收到requestBuffer请求后，会实际分配内存，将其句柄handle通过binder的序列化接口传送到客户端。<br>通过handle句柄，Client端（应用）可以将指定的内存区域映射到自己的进程空间中，而这块区域与BufferQueue中所指向的物理空间是一致的，从而成功地实现了缓冲区的共享。handle它实际上是GraphicBuffer中打开的一个ashmem句柄，因而也就是两边进程共享缓冲区的关键。</p>
<h2 id="应用程序的典型绘图流程"><a href="#应用程序的典型绘图流程" class="headerlink" title="应用程序的典型绘图流程"></a>应用程序的典型绘图流程</h2><p>原文：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954840" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954840</a></p>
<p>应用程序并不会直接使用BufferQueue。和Android系统中很多其它地方一样，“层层包裹”在这里同样是存在的。</p>
<p>我们选取系统的开机动画这一应用程序，来分析整个图形绘制的流程。值得一提的是，这个开机动画的实现符合前面提到的两个改进的图形系统中的第一个，即应用程序与SurfaceFlinger都是使用OpenGL ES来完成UI显示，不过因为它是一个C++程序，所以不需要上层GLSurfaceView的支持。</p>
<p>这个开机动画的实现类是BootAnimation，它的内部就是借助SurfaceFlinger来完成的。</p>
<p>BootAnimation是一个C++程序，其工程源码路径是/frameworks/base/cmds/bootanimation。和很多native应用一样，它也是在init脚本中被启动的，大概来看下这一过程。</p>
<pre><code>service bootanim /system/bin/bootanimation
    class main
    user graphics
    group graphics
    disabled
    oneshot
</code></pre><p>当bootanimation被启动后，它首先会进入main函数，即main@Bootanimation_main.cpp，生成一个BootAnimation对象，并开启线程池(因为它需要与SurfaceFlinger等系统服务进行跨进程的通信)。在BootAnimation的构造函数中，同时生成一个SurfaceComposerClient：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BootAnimation::BootAnimation() : Thread(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    mSession = newSurfaceComposerClient();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ISurfaceTexture是应用程序与BufferQueue的传输通道，而ISurfaceComposerClient则是它与SurfaceFlinger间的桥梁。</strong></p>
<p>个人理解：ISurfaceTexture 封装对BufferQueue的访问，将绘制的内容放在缓冲区上。而ISurfaceComposerClient 负责告诉SurfaceFlinger这些缓冲区的元数据，以便SurfaceFlinger采用合适的参数对绘制缓冲（surface）做进一步的合成。</p>
<p>这样子的设计是合理的，体现了模块化的思想——SurfaceFlinger的职责是“Flinger”，即把系统中所有应用程序的最终的“绘图结果”进行“混合”，然后统一显示到物理屏幕上。它不应该，也没有办法分出太多的精力去一一关注各个应用程序的“绘画过程”。这个光荣的任务自然而然地落在了BufferQueue的肩膀上，它是每个应用程序“一对一”的辅导老师，指导着UI程序的“画板申请”、“作画流程”等一系列细节。下面的图描述了这三者的关系：</p>
<p><img src="/img/android_graphic_system_10.png" alt=""></p>
<p>的确是太乱了，我们有必要先来整理下目前已经出现的容易混淆的相关类的关系：</p>
<ul>
<li><strong>ISurfaceComposerClient</strong>: 应用程序与SurfaceFlinger间的通道，在应用进程中则被封装在SurfaceComposerClient这个类中。这是一个匿名binder server，由应用程序(具体位置在SurfaceComposerClient::onFirstRef中)调用SurfaceFlinger这个实名binder的createConnection方法来获取到，服务端的实现是SurfaceFlinger::Client。</li>
<li><strong>ISurface</strong>:由应用程序调用ISurfaceComposerClient::createSurface()得到，同时在SurfaceFlinger这一进程中将会有一个Layer被创建，代表了一个“画面”。ISurface就是控制这一画面的handle。</li>
<li><strong>Surface</strong>:从逻辑关系上看，它是上述<strong>ISurface</strong>的使用者。从继承关系上看，它是一个<strong>SurfaceTextureClient</strong>，也就是本地窗口。SurfaceTextureClient内部持有<strong>ISurfaceTexture</strong>，即<strong>BufferQueue</strong>的实现接口。换个角度来思考，当EGL想通过Surface这个native window完成某些功能时，后者实际上又利用ISurface和ISurfaceTexture来取得远程服务端的对应服务，以完成EGL的请求。</li>
<li><strong>Layer</strong>：既然Layer代表了一个画面图层，那么它肯定需要有存储图层数据的地方。当应用端通过ISurfaceComposerClient::createSurface()来发起创建Surface的请求时，SurfaceFlinger服务进程这边会创建一个Layer。</li>
</ul>
<p>一个典型的应用程序使用SurfaceFlinger进行绘图的流程如下图所示：<br><img src="/img/android_graphic_system_11.png" alt=""></p>
<p>各个class之间的关系式这样的：<br><img src="/img/android_graphic_system_12.png" alt=""></p>
<h2 id="应用程序与BufferQueue的关系"><a href="#应用程序与BufferQueue的关系" class="headerlink" title="应用程序与BufferQueue的关系"></a>应用程序与BufferQueue的关系</h2><p>原文：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954853" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954853</a></p>
<p>应用程序与BufferQueue的关系就比较明朗了。虽然中间经历了多次跨进程通信，但对于应用程序来说最终只使用到了BufferQueue(通过ISurfaceTexture)。从本小节的内容中，我们也可以从侧面证明如下几个关键点：</p>
<ol>
<li>应用程序可以调用createSurface来建立多个Layer，它们是一对多的关系。理由就是createSurface中没有任何机制来限制应用程序的多次调用，相反，它会把一个应用程序多次申请而产生的Layer统一管理。为应用程序申请的layer，一方面需要告知SurfaceFlinger，另一方面也要记录到各Client内部中，这两个步骤是由addClientLayer()分别调用Client::attachLayer()和SurfaceFlinger::addLayer_l()来完成的。对于SurfaceFlinger，它需要对系统中当前所有的Layer进行Z-order排序，以决定用户所能看到的“画面”是什么样的。对于Client，它则利用内部的mLayers成员变量来一一记录新增(attachLayer)和移除(detachLayer)的图层。</li>
<li>每个Layer对应一个BufferQueue，换句话说，一个应用程序可能对应多个BufferQueue。Layer没有直接持有BufferQueue，而是由其内部的mSurfaceTexture来管理。</li>
</ol>
<p><img src="/img/android_graphic_system_13.png" alt=""></p>
<p><img src="/img/android_graphic_system_14.png" alt=""></p>
<p>图 11‑19 应用程序与BufferQueue的对应关系</p>
<hr>
<h1 id="SurfaceFlinger"><a href="#SurfaceFlinger" class="headerlink" title="SurfaceFlinger"></a>SurfaceFlinger</h1><h2 id="Project-Butter黄油计划"><a href="#Project-Butter黄油计划" class="headerlink" title="Project Butter黄油计划"></a>Project Butter黄油计划</h2><p>原文：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954869" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954869</a></p>
<p>CPU、GPU负责渲染帧数据，Display负责屏幕的显示。<br>FPS（Frame peer Second） 代表CPU、GPU每秒能够渲染的桢数量。<br>刷新率 代表 显示设备的刷新率。<br>VSync(垂直同步)是VerticalSynchronization的简写，它利用VBI时期出现的vertical sync pulse来保证双缓冲在最佳时间点才进行交换。</p>
<p><img src="/img/android_graphic_system_15.png" alt=""><br>图 11‑22绘图过程没有采用VSync同步的情况</p>
<p><img src="/img/android_graphic_system_16.png" alt=""><br>图 11‑25 FPS低于屏幕刷新率的情况</p>
<p>当CPU/GPU的处理时间超过16ms时，第一个VSync到来时，缓冲区B中的数据还没有准备好，于是只能继续显示之前A缓冲区中的内容。而B完成后，又因为缺乏VSync pulse信号，它只能等待下一个signal的来临。于是在这一过程中，有一大段时间是被浪费的。当下一个VSync出现时，CPU/GPU马上执行操作，此时它可操作的buffer是A，相应的显示屏对应的就是B。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”。</p>
<p>为了避免tear，当FPS &gt; 刷新率时，采用双缓冲技术。当收到VSync，CPU/GPU立即开始准备新的frame；而Display则显示之间已经准备好的frame。<br>当FPS &lt; 刷新率时，采用三缓冲技术，保证frame准备好能够尽快显示。这时候如果采用双缓冲，准备好的帧可能需要等待近一个VSync周期才能显示。</p>
<h2 id="SurfaceFlinger的启动与工作原理"><a href="#SurfaceFlinger的启动与工作原理" class="headerlink" title="SurfaceFlinger的启动与工作原理"></a>SurfaceFlinger的启动与工作原理</h2><p>原文：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954951" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954951</a></p>
<h2 id="SurfaceComposerClient"><a href="#SurfaceComposerClient" class="headerlink" title="SurfaceComposerClient"></a>SurfaceComposerClient</h2><p>原文：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954957" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954957</a></p>
<p><img src="/img/android_graphic_system_17.png" alt=""><br>图 11‑28 每个应用程序在SurfaceFlinger中都对应一个Client</p>
<p>SurfaceFlinger运行于SystemServer这一系统进程中，需要UI界面显示的应用程序则通过binder服务与它进行跨进程通信。在音频系统的学习中，每一个AudioTrack在AudioFlinger中都可以找到一个对应的Track实现。这种设计方式同样适用于显示系统，即任何有UI界面的程序都在SurfaceFlinger中有且仅有一个Client实例。</p>
<p>应用程序与SurfaceFlinger间的接口是<strong>ISurfaceComposerClient</strong>，<strong>Client</strong>的父类是BnSurfaceComposerClient,它是这一接口的本地端实现。</p>
<p>ISurfaceComposerClient接口中最重要的两个方法createSurface()和destroySurface()分别用于向SurfaceFlinger申请和销毁一个ISurface。<strong>那么既然有了Client，为什么还要再引出另一个binder对象呢？</strong></p>
<p>这是因为每个SurfaceFlinger的<strong>客户程序</strong>都只会有唯一一个Client连接，但它们<strong>内部拥有的Surface数量却很可能有多个</strong>。通常情况下，同一个Activity中的UI布局共用系统分配的Surface进行绘图，但像SurfaceView这种UI组件就是特例——它独占一个Surface进行绘制。举个例子来说，如果我们制作一个带SurfaceView的视频播放器，其所在的应用程序最终就会有不止一个的Surface存在。这样设计是必须的，因为播放视频对刷新频率要求很高，采用单独的Surface既可以保证视频的流畅度，也同时能让用户的交互动作(比如触摸屏操作)及时得到响应。</p>
<p><img src="/img/android_graphic_system_18.png" alt=""></p>
<h1 id="VSync"><a href="#VSync" class="headerlink" title="VSync"></a>VSync</h1><p>原文：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954986" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954986</a></p>
<p>Android 4.1显示系统中的新特性，其中一个就是加入了VSync同步。<br>VSync信号是如何产生的呢？<br>在Android源码surfaceflinger目录下有一个displayhardware文件夹，其中HWComposer的主要职责之一，就是用于产生VSync信号。<strong>VSync信号源 可以是硬件的，也可以是软件模拟的</strong>。<br>分析HWComposer::HWComposer（…）,假如当前系统可以成功加载HWC_HARDWARE_MODULE_ID=“hwcomposer”，并且通过这个库模块能顺利打开设备(hwc_composer_device_t)，其版本号又大于HWC_DEVICE_API_VERSION_0_3的话，我们就采用“<strong>硬件源</strong>”(此时needVSyncThread为false)，否则需要创建一个新的VSync线程来模拟产生信号。</p>
<h2 id="VSync信号的产生和分发"><a href="#VSync信号的产生和分发" class="headerlink" title="VSync信号的产生和分发"></a>VSync信号的产生和分发</h2><h2 id="VSync信号的处理"><a href="#VSync信号的处理" class="headerlink" title="VSync信号的处理."></a>VSync信号的处理.</h2><p><a href="http://blog.csdn.net/xuesen_lin/article/details/8955012" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8955012</a></p>
<p>现在SurfaceFlinger只处理REFRESH一个消息，其主要工作是：</p>
<ul>
<li>handleTransaction<br>即处理事务，什么样的事务呢？在SurfaceFlinger::setTransactionState()中我们可以看到，假如当前的orientation和新的不符合时，会将eTransactionNeeded置位;当应用程序请求createSurface、removeSurface，或者addLayer、removeLayer时也会把它置位。另一个flag被置位的情况则包括：layer的size、alpha、matrix、transparentregion、visibility变化等等。<br>总结起来，就是当与系统显示相关的状态(比如新增/减少了Surface，显示屏的变化等等)改变，或者某个Layer自身状态(比如它的大小尺寸、可见性、透明度等等)改变时，就需要执行Transaction。</li>
<li>handlePageFlip<br>由前面的分析我们知道，每个Layer对应着最多32个BufferSlot，这样系统在进行一次刷新时，必须先决定使用哪个buffer，并利用这一缓冲区更新纹理。另外，我们还需要计算所有图层的可见区域和“脏区域”，以便最终的合成显示。</li>
<li>handleRefresh<br>版本更新遗留下的函数，当前实现中没有起到作用，相信在后续升级中会进一步完善。</li>
<li>handleWorkList<br>创建HWComposer中的mList，这个列表将用于后续的layer合成。这个函数比较简单，我们不单独介绍。</li>
<li>handleRepaint<br>计算出最终的脏区域，并执行实际的合成工作(composeSurfaces)，我们将做详细源码分析。</li>
<li>postFramebuffer<br>将上一步中生成的缓冲区数据post到framebuffer中，这样才能真正在物理屏幕上显示出来。分为两条路径，即HWComposer::commit和直接调用eglSwapBuffers()</li>
</ul>
<h2 id="handleTransaction"><a href="#handleTransaction" class="headerlink" title="handleTransaction"></a>handleTransaction</h2><p><a href="http://blog.csdn.net/xuesen_lin/article/details/8955121" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8955121</a></p>
<h2 id="handlePageFlip"><a href="#handlePageFlip" class="headerlink" title="handlePageFlip"></a>handlePageFlip</h2><p><a href="http://blog.csdn.net/xuesen_lin/article/details/8955138" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8955138</a></p>
<h2 id="handleRefresh"><a href="#handleRefresh" class="headerlink" title="handleRefresh"></a>handleRefresh</h2><p><a href="http://blog.csdn.net/xuesen_lin/article/details/8955173" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8955173</a></p>
<h2 id="handleRepaint"><a href="#handleRepaint" class="headerlink" title="handleRepaint"></a>handleRepaint</h2><p><a href="http://blog.csdn.net/xuesen_lin/article/details/8955183" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8955183</a></p>
<h2 id="postFramebuffer"><a href="#postFramebuffer" class="headerlink" title="postFramebuffer"></a>postFramebuffer</h2><p><a href="http://blog.csdn.net/xuesen_lin/article/details/8955198" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8955198</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://blog.andjoin.com/2015/07/01/android_graphic_system/" data-id="cipdhm0ih00047ljwu7y3ty9a" class="article-share-link" data-share="baidu" data-title="[摘]Android 图形系统 （Android 4.3）">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/framework/">framework</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/graphic/">graphic</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-adb service out of date" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/30/adb service out of date/" class="article-date">
  <time datetime="2015-06-30T02:13:49.000Z" itemprop="datePublished">2015-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/30/adb service out of date/">如何解决adb过时问题：adb service out of date</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>参考文献： <a href="http://my.oschina.net/u/924450/blog/179519" target="_blank" rel="external">http://my.oschina.net/u/924450/blog/179519</a></p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在我的工作环境下，很容易出现adb service out of date问题，影响远程调试。通常，下列情况会出现该问题：</p>
<ul>
<li>重新插拔USB线</li>
<li>adb remount</li>
<li>adb root</li>
</ul>
<h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><ol>
<li><p>确保adbd 进程被杀掉，然后重新插上USB线。看看能不能启动adbd</p>
<pre><code>&gt;adb nodaemon server
cannot bind &apos;tcp:5037&apos;
</code></pre></li>
<li><p>检查5037端口的占用情况，原来是进程4172</p>
<pre><code>&gt;netstat -ano | findstr &quot;5037&quot;
协议  本地地址                    外部地址             状态            PID
TCP    127.0.0.1:5037         0.0.0.0:0              LISTENING       4172
TCP    127.0.0.1:5037         127.0.0.1:54592        TIME_WAIT       0
TCP    127.0.0.1:5037         127.0.0.1:54600        TIME_WAIT       0
TCP    127.0.0.1:5037         127.0.0.1:54603        TIME_WAIT       0
TCP    127.0.0.1:54592        127.0.0.1:5037         TIME_WAIT       0
TCP    127.0.0.1:54598        127.0.0.1:5037         TIME_WAIT       0
TCP    127.0.0.1:54599        127.0.0.1:5037         TIME_WAIT       0
TCP    127.0.0.1:54602        127.0.0.1:5037         TIME_WAIT       0
</code></pre></li>
<li><p><strong>找到4172该进程，发现是搜狗拼音输入法的SogouPhoneService.exe。作为一个拼音输入法，你没事去监听5037端口干什么？处理办法：</strong></p>
</li>
<li>杀无赦，</li>
<li>然后删除对应的exe文件。</li>
<li><p>然后在exe所在的文件夹，新建一个名字为SogouPhoneService.exe的空目录，以防搜狗自动恢复该exe文件。</p>
</li>
<li><p>再次查看5037端口，这次是adb进程了</p>
<pre><code>&gt;adb start-server
&gt;
&gt;netstat -ano | findstr 5037
TCP    127.0.0.1:5037         0.0.0.0:0              LISTENING       7248
</code></pre></li>
</ol>
<p>5.OVER</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>adb service out of date的原因就是其他程序抢占了该端口。</p>
<p>除了adb service外，任何跑去监听5037端口的行为都是不能看做是善意的。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://blog.andjoin.com/2015/06/30/adb service out of date/" data-id="cipdhm0hw00007ljwdd64hl87" class="article-share-link" data-share="baidu" data-title="如何解决adb过时问题：adb service out of date">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/adb/">adb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/howto/">howto</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-selinux_exemem" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/19/selinux_exemem/" class="article-date">
  <time datetime="2015-06-19T03:21:49.000Z" itemprop="datePublished">2015-06-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/security/">security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/19/selinux_exemem/">SELinux: 什么是process::execmem权限？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><pre><code>class process
{
...
    execmem
    execstack
    execheap
...
}
</code></pre><ul>
<li><strong>execmem</strong><br>Make executable an anonymous mapping or private file mapping that is<br>writable</li>
<li><strong>execheap</strong>: Make the heap executable.</li>
<li><strong>execstack</strong>: Make the main process stack executable.</li>
</ul>
<h1 id="相关allow规则"><a href="#相关allow规则" class="headerlink" title="相关allow规则"></a>相关allow规则</h1><pre><code>tios_zygote.te(69):allow tios_zygote self:process execmem;
tios_radio.te(58):allow tios_radio self:process execmem;
tiosappdomain.te(3):allow tiosappdomain self:process execmem;
tios_unconfined.te(11):allow tios_unconfined self:process execmem;

recovery.te(63):  allow recovery self:process execmem;
system_server.te(10):allow system_server self:process execmem;
healthd.te(36):allow healthd self:process execmem;
dumpstate.te(84):allow dumpstate self:process execmem;
mediaserver.te(17):allow mediaserver self:process execmem;
app.te(10):allow appdomain self:process execmem;
</code></pre><p>在android中,execmem 主要与dalvik有关：</p>
<pre><code>system_server.te
...
# Dalvik Compiler JIT Mapping.
allow system_server self:process execmem;
allow system_server ashmem_device:chr_file execute;
allow system_server system_server_tmpfs:file execute;
....
</code></pre><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><h2 id="English"><a href="#English" class="headerlink" title="English"></a>English</h2><ul>
<li><strong>execmem</strong> is purely a task-self check, i.e. a process can either make an anonymous mapping executable (and thus execute arbitrary code) or not.</li>
<li><strong>execmod</strong> is a task-file check to allow finer granularity for the case of text relocations; it is applied when a process attempts to make a modified private file mapping executable, which normally only occurs for text relocations.  Thus, under strict policy, execmod is normally restricted to a particular file type (texrel_shlib_t) and all files requiring text relocation must be explicitly labeled with that type in order to allow the relocation.  allow_execmod just controls whether or not execmod is <em>ever</em> allowed, but even when it is enabled, you are still limited to texrel_shlib_t.<h2 id="中文版解释"><a href="#中文版解释" class="headerlink" title="中文版解释"></a>中文版解释</h2></li>
<li>execmem纯粹是任务自身的一种检查，例如，进程可以设置或者取消匿名映射内存 的可执行能力。如果设置该能力，也就可以执行任意代码。</li>
<li>execmode则是对文本重定位（text relocation）的更好粒度的任务文件检查。当进程试图将修改过的私有文件映射变为可执行时（通常仅发生于文本重定位），执行该检查。因此，在策略限制下，execmod用于限制特定的文件类型（texrel_shlib_t）,所有要求文本重定位的文件必须显示标记为该类型。allow_execmod 仅控制execmod是否 ”曾经“被容许，但即使被allow，其文本类型仍限制为texrel_shlib_t.</li>
</ul>
<h1 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h1><ul>
<li><a href="https://www.redhat.com/archives/fedora-selinux-list/2005-June/msg00152.html" target="_blank" rel="external">allow execmod and execmem for self debugging process</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://blog.andjoin.com/2015/06/19/selinux_exemem/" data-id="cipdhm0jz000n7ljwq7p5xyb6" class="article-share-link" data-share="baidu" data-title="SELinux: 什么是process::execmem权限？">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SELinux/">SELinux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-selinux_iptable_SECMARK" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/18/selinux_iptable_SECMARK/" class="article-date">
  <time datetime="2015-05-18T08:19:53.000Z" itemprop="datePublished">2015-05-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/security/">security</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/18/selinux_iptable_SECMARK/">SELinux: 利用iptable 的 SECMARK 机制来为Android网络通信进行MAC访问控制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>为对AF_INET socket实施访问控制，你需要使用某种方法对数据包添加标签，并且通过网络栈在数据包中传递这些标签。这种做法并不常用，当SELinux出现时，主流Linux甚至不支持该方式。不过现在，SELinux中已经整合了两种数据包标记方式.</p>
<h1 id="SECMARK"><a href="#SECMARK" class="headerlink" title="SECMARK"></a>SECMARK</h1><p>SECMARK 基于iptable 配置中的报文特征来设置数据包标签，然后执行send/recv策略检查。策略的组成是：sender 域、receiver域 以及数据包类型。为启用SECMARK机制，你需要在kernel中开启相应的支持，并且配置iptable SECMARK或者CONNSECMARK规则。这些报文标签仅存在于本机的网络协议栈，并不会传播到其他主机。</p>
<p>SEC处理过程：<br><img src="/img/selinux_iptable_SECMARK_01.png" alt="SECMARK处理过程"></p>
<h1 id="Labeled-XFRM-or-NetLabel"><a href="#Labeled-XFRM-or-NetLabel" class="headerlink" title="Labeled XFRM or NetLabel"></a>Labeled XFRM or NetLabel</h1><p>基于发送者来标记保温的两种机制。其报文标签可以传播到远程系统，然后在接收时执行安全检查。其安全策略包含sender 域、receiver域 以及数据包类型。</p>
<h2 id="Labeled-XFRM"><a href="#Labeled-XFRM" class="headerlink" title="Labeled XFRM"></a>Labeled XFRM</h2><p>该机制将报文标签保存在一个IPSEC安全关联中，由接收端从SA中推断报文标签。</p>
<h2 id="NetLabel"><a href="#NetLabel" class="headerlink" title="NetLabel"></a>NetLabel</h2><p>该机制将安全标签保存在通过某个IP选项（例如：CIPSO）保存在每个报文中。如果需要在Android上支持NetLabel机制，开发者需要开启相关内核选项，并一直netlabelctl</p>
<h1 id="Android支持"><a href="#Android支持" class="headerlink" title="Android支持"></a>Android支持</h1><p>在Android上启用SECMARK机制非常容易，因为我们已经将内核配置选项增加到了android-base.cfg中，iptables SECMARK支持已经被包含其中。</p>
<h2 id="内核支持"><a href="#内核支持" class="headerlink" title="内核支持"></a>内核支持</h2><p>你需要检查并启用下列Android 内核配置项：</p>
<ul>
<li>CONFIG_NETWORK_SECMARK=y</li>
<li>CONFIG_IP_NF_SECURITY=y</li>
<li>CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y</li>
<li>CONFIG_NETFILTER_XT_TARGET_SECMARK=y</li>
<li>CONFIG_NF_CONNTRACK_SECMARK=y</li>
</ul>
<p>目前，这些配置型属于android-base.cfg的一部分。不过我在MSM8939 Android5.0.2中的源码树中没有找到相关配置。</p>
<h2 id="设置规则"><a href="#设置规则" class="headerlink" title="设置规则"></a>设置规则</h2><p>iptable SECMARK规则可以用来对报文进行标记，例如：</p>
<pre><code>iptables -t security -A INPUT -p tcp --dport 4591 -j SECMARK --selctx u:object_r:http_packet_t:s0&quot;
iptables -t mangle -A OUTPUT -p tcp --sport 4591 -j SECMARK --selctx  u:object_r:http_packet_t:s0
</code></pre><p>你还需要为你希望收发任何报文增加规则，否则收发将被拒绝：</p>
<pre><code>#容许收发未标记的报文
allow domain unlabeled:packet { send recv};
#容许platform_app  域的进程收发标记为http_packet_t的报文
allow platform_app http_packet_t:packet { recv send };
</code></pre><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://bitbucket.org/seandroid/external-sepolicy/commits/70d4fc2243721a54cd177959e05cf81b54c4e226" target="_blank" rel="external">Add selinux network script to policy</a></li>
<li><a href="http://selinuxproject.org/page/NB_Networking" target="_blank" rel="external">SELinux Networking Support</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://blog.andjoin.com/2015/05/18/selinux_iptable_SECMARK/" data-id="cipdhm0kc000x7ljw45cpbo06" class="article-share-link" data-share="baidu" data-title="SELinux: 利用iptable 的 SECMARK 机制来为Android网络通信进行MAC访问控制">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SELinux/">SELinux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iptable/">iptable</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
    </nav>
  
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/OpenCourse/">OpenCourse</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/OpenCourse/security/">security</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/android/security/">security</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">security</a><span class="category-list-count">9</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/security/OpenCourse/">OpenCourse</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/python/">python</a><span class="category-list-count">1</span></li></ul></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BYOD/">BYOD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BigData/">BigData</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LSM/">LSM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SELinux/">SELinux</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/adb/">adb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c++</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/crypt/">crypt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/framework/">framework</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/graphic/">graphic</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/howto/">howto</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iptable/">iptable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/">security</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/setools4/">setools4</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/BYOD/" style="font-size: 10px;">BYOD</a> <a href="/tags/BigData/" style="font-size: 10px;">BigData</a> <a href="/tags/LSM/" style="font-size: 10px;">LSM</a> <a href="/tags/SELinux/" style="font-size: 20px;">SELinux</a> <a href="/tags/adb/" style="font-size: 10px;">adb</a> <a href="/tags/c/" style="font-size: 10px;">c++</a> <a href="/tags/crypt/" style="font-size: 10px;">crypt</a> <a href="/tags/framework/" style="font-size: 10px;">framework</a> <a href="/tags/graphic/" style="font-size: 10px;">graphic</a> <a href="/tags/howto/" style="font-size: 13.33px;">howto</a> <a href="/tags/iptable/" style="font-size: 10px;">iptable</a> <a href="/tags/security/" style="font-size: 16.67px;">security</a> <a href="/tags/setools4/" style="font-size: 10px;">setools4</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/06/13/selinux_howto_create_data_dir_for_app/">SELinux: 如何为进程创建专有的数据目录？</a>
          </li>
        
          <li>
            <a href="/2016/06/13/introduction_bigdata/">大数据的十个技术前沿</a>
          </li>
        
          <li>
            <a href="/2016/06/13/selinux_implement_as_LSM/">SELinux 基于LSM的实现</a>
          </li>
        
          <li>
            <a href="/2016/06/13/introduction-information-security/">信息安全管理介绍</a>
          </li>
        
          <li>
            <a href="/2016/06/13/algorithm_name_match/">人名匹配问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://github.com" target="_blank">github</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 LargeRiver<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js"></script>

</div>
</body>
</html>
