
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>[摘]Android 图形系统 （Android 4.3） | 牧云人</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言本文摘自 《深入理解Android设计思想》
在Android4.3之前的版本中，最终的显示工作是要交给FrameBuffer的，而从4.3开始，合成工作由SurfaceFlinger交给硬件合成器来完成，显示工作将由硬件合成器HAL来完成。参考链接：http://blog.csdn.net/xuesen_lin/article/details/8954508">
<meta property="og:type" content="article">
<meta property="og:title" content="[摘]Android 图形系统 （Android 4.3）">
<meta property="og:url" content="http://blog.andjoin.com/2015/07/01/Android/android_graphic_system/index.html">
<meta property="og:site_name" content="牧云人">
<meta property="og:description" content="前言本文摘自 《深入理解Android设计思想》
在Android4.3之前的版本中，最终的显示工作是要交给FrameBuffer的，而从4.3开始，合成工作由SurfaceFlinger交给硬件合成器来完成，显示工作将由硬件合成器HAL来完成。参考链接：http://blog.csdn.net/xuesen_lin/article/details/8954508">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_01.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_02.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_03.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_04.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_05.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_06.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_07.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_08.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_09.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_10.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_11.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_12.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_13.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_14.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_15.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_16.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_17.png">
<meta property="og:image" content="http://blog.andjoin.com/img/android_graphic_system_18.png">
<meta property="og:updated_time" content="2016-06-13T04:49:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[摘]Android 图形系统 （Android 4.3）">
<meta name="twitter:description" content="前言本文摘自 《深入理解Android设计思想》
在Android4.3之前的版本中，最终的显示工作是要交给FrameBuffer的，而从4.3开始，合成工作由SurfaceFlinger交给硬件合成器来完成，显示工作将由硬件合成器HAL来完成。参考链接：http://blog.csdn.net/xuesen_lin/article/details/8954508">
<meta name="twitter:image" content="http://blog.andjoin.com/img/android_graphic_system_01.png">
  
    <link rel="alternative" href="/atom.xml" title="牧云人" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">牧云人</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="blog.andjoin.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-Android/android_graphic_system" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/01/Android/android_graphic_system/" class="article-date">
  <time datetime="2015-07-01T02:13:49.000Z" itemprop="datePublished">2015-07-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      [摘]Android 图形系统 （Android 4.3）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文摘自 《深入理解Android设计思想》</p>
<p>在Android4.3之前的版本中，最终的显示工作是要交给FrameBuffer的，而从4.3开始，合成工作由SurfaceFlinger交给硬件合成器来完成，显示工作将由硬件合成器HAL来完成。<br>参考链接：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954508" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954508</a><br><a id="more"></a></p>
<h1 id="OpenGL-ES与EGL"><a href="#OpenGL-ES与EGL" class="headerlink" title="OpenGL ES与EGL"></a>OpenGL ES与EGL</h1><p><strong>SurfaceFlinger</strong>虽然是GUI的核心，但相对于OpenGL ES来讲，它其实<strong>只是一个“应用”</strong>。</p>
<p><img src="/img/android_graphic_system_01.png" alt=""><br>我们根据上面这个图，由底层往上层来逐步分析整个架构：</p>
<ol>
<li>Linux内核提供了统一的framebuffer显示驱动，设备节点/dev/graphics/fb<em>或者/dev/fb</em>，以fb0表示第一个Monitor，当前实现中只用到了一个显示屏</li>
<li><p>Android的HAL层提供了Gralloc，分为fb和gralloc两个设备。</p>
<ul>
<li><strong>fb 负责内核中framebuffer</strong>的打开、初始化配置，以及提供post、setSwapInterval等操作</li>
<li><strong>Gralloc 则管理帧缓冲区的分配和释放</strong>。上层只能通过Gralloc访问帧缓冲区，这样一来就实现了有序的封装保护</li>
</ul>
</li>
<li><p>由于<strong>OpenGL ES是一个通用的函数库</strong>，在不同的平台系统上需要被“本地化”——即把它与具体平台上的窗口系统建立起关联，这样才能保证它正常工作。从FramebufferNativeWindow这个名称就能判断出来，它就是将OpenGL ES在Android平台上本地化的中介之一。后面我们还会看到应用程序端所使用的另一个“本地窗口”。为OpengGL ES配置本地窗口的是EGL</p>
</li>
<li><strong>OpenGL或者OpenGL ES 更多的只是一个接口协议，实现上既可以采用软件，也能依托于硬件。</strong>这一方面给产品开发带来了灵活性，我们可以根据成本与市场定位来决定具体的硬件设计，从而达到很好的定制需求;另一方面，既然有多种实现的可能，那么OpenGL ES在运行时是如何取舍的呢？这也是EGL的作用之一。它会去读取egl.cfg这个配置文件，然后根据用户的设定来动态加载libagl(软件实现)或者libhgl(硬件实现)。然后上层才可以正常使用各种glXXX接口</li>
<li><p>SurfaceFlinger中持有一个GraphicPlane成员变量mGraphicPlanes来描述“显示屏”;GraphicPlane类中又包含了一个DisplayHardware对象实例(mHw)。具体是在SurfaceFlinger::readyToRun中，完成对它们的创建与初始化。并且DisplayHardware在初始化时还将调用eglInitialize、eglCreateWindowSurface等接口，利用EGL来完成对OpenGLES环境的搭建。其中:</p>
<pre><code>surface =**eglCreateWindowSurface**(display, config, mNativeWindow.get(), NULL);
</code></pre><p>mNativeWindow 就是一个FramebufferNativeWindow对象。DisplayHardware为OpenGL ES设置了“本地化”所需的窗口</p>
</li>
<li><p>很多模块都可以调用OpenGLES提供的API(这些接口以“gl”为前缀，比如glViewport、glClear、glMatrixMode、glLoadIdentity等等)，包括SurfaceFlinger、DisplayHardware等</p>
</li>
<li><p>与OpenGL ES相关的模块，可以分为如下几类：</p>
<ul>
<li>配置类  即帮助OpenGL ES完成配置的，包括<strong>EGL</strong>、DisplayHardware都可以认为是这一类</li>
<li>依赖类  也就是OpenGL ES要正常运行起来所依赖的“本地化”的东西，上图中是指FramebufferNativeWindow</li>
<li>使用类  使用者也可能是配置者，比如DisplayHardware既扮演了“帮助”OpenGL的角色，同时它也是其使用方。另外只要处在与OpenGL ES同一个环境(Context)中的模块，都可以使用它来完成操作，比如SurfaceFlinger</li>
</ul>
</li>
</ol>
<h1 id="Gralloc与Framebuffer"><a href="#Gralloc与Framebuffer" class="headerlink" title="Gralloc与Framebuffer"></a>Gralloc与Framebuffer</h1><h2 id="Gralloc库的加载"><a href="#Gralloc库的加载" class="headerlink" title="Gralloc库的加载"></a>Gralloc库的加载</h2><p>Gralloc对应的模块是由<strong>FramebufferNativeWindow</strong>(OpenGLES的本地窗口之一，后面小节有详细介绍)在构造时加载的：</p>
<pre><code>hw_get_module(HWC_HARDWARE_MODULE_ID, &amp;mModule);
</code></pre><p>这个<strong>hw_get_module</strong>函数我们在前面已经见过很多次了，它是上层加载HAL库的入口，这里传入的模块ID名为：</p>
<pre><code>#define GRALLOC_HARDWARE_MODULE_ID  &quot;gralloc&quot;
</code></pre><p>按照hw_get_module的作法，它会在如下路径中查找与ID值匹配的库：</p>
<pre><code>#define HAL_LIBRARY_PATH1 &quot;/system/lib/hw&quot;
#define HAL_LIBRARY_PATH2 &quot;/vendor/lib/hw&quot;
</code></pre><p>Gralloc对应的 lib库名有如下几种形式：</p>
<pre><code>gralloc.[ro.hardware].so
gralloc.[ro.product.board].so
gralloc.[ro.board.platform].so
gralloc.[ro.arch].so
</code></pre><p>或者当上述的系统属性组成的文件名都不存在时，就使用默认的：</p>
<pre><code>gralloc.default.so
</code></pre><p>最后这个库是Android原生态的实现，位置在hardware/libhardware/modules/gralloc/中，它由gralloc.cpp、framebuffer.cpp和mapper.cpp三个主要源文件编译生成。</p>
<h2 id="Gralloc提供的接口"><a href="#Gralloc提供的接口" class="headerlink" title="Gralloc提供的接口"></a>Gralloc提供的接口</h2><p>Gralloc实际操作了两个设备：</p>
<ul>
<li>fb0 就是我们前面说的主屏幕，</li>
<li>gpu0负责图形缓冲区的分配和释放。<br><img src="/img/android_graphic_system_02.png" alt=""></li>
</ul>
<h1 id="本地窗口"><a href="#本地窗口" class="headerlink" title="本地窗口"></a>本地窗口</h1><p><a href="http://blog.csdn.net/xuesen_lin/article/details/8954748" target="_blank" rel="external">原文</a></p>
<p>在OpenGL的学习过程中，我们不断提及“本地窗口”(NativeWindow)这一概念。那么对于Android系统来说，它是如何将OpenGL ES本地化的呢，或者说，它提供了什么样的本地窗口？<br>根据整个Android系统的GUI设计理念，我们不难猜想到至少需要两种本地窗口：</p>
<ol>
<li>面向管理者(SurfaceFlinger) 。既然SurfaceFlinger扮演了系统中所有UI界面的管理者，那么它无可厚非地需要直接或间接地持有“本地窗口”。从前一小节我们已经知道，这个窗口就是<strong>FramebufferNativeWindow</strong>。</li>
<li>面向应用程序。我们先给出答案，这类窗口是<strong>SurfaceTextureClient</strong></li>
</ol>
<h2 id="为什么需要两种窗口系统"><a href="#为什么需要两种窗口系统" class="headerlink" title="为什么需要两种窗口系统"></a>为什么需要两种窗口系统</h2><h3 id="理想的窗口系统"><a href="#理想的窗口系统" class="headerlink" title="理想的窗口系统"></a>理想的窗口系统</h3><p><img src="/img/android_graphic_system_03.png" alt=""><br>理想的窗口系统</p>
<p>假如整个系统仅有一个需要显示UI的程序，我们有理由相信它是可以胜任的。但是如果有N个UI程序的情况呢？Framebuffer显然只有一个，不可能让各个应用程序自己单独管理。</p>
<h3 id="改进的窗口系统"><a href="#改进的窗口系统" class="headerlink" title="改进的窗口系统"></a>改进的窗口系统</h3><p><img src="/img/android_graphic_system_04.png" alt=""><br>改进的窗口系统</p>
<p>在这个改进的窗口系统中，我们有了两类本地窗口，即Window-1和Window-2。</p>
<ol>
<li><strong>第一种窗口</strong>是能直接显示在终端屏幕上的——它<strong>使用了帧缓冲区</strong>，</li>
<li>而<strong>后一种Window实际上是从内存缓冲区分配的空间</strong>。</li>
</ol>
<p>当系统中存在多个应用程序时，这能保证它们都可以获得一个“本地窗口”，并且这些窗口最终也能显示到屏幕上——SurfaceFlinger会收集所有程序的显示需求，对它们做统一的图像混合操作(有点类似于AudioFlinger)，然后输出到自己的Window-1上。<br>当然，这个改进的窗口系统有一个前提，即应用程序与SurfaceFlinger都是基于OpenGL ES来实现的。有没有其它选择呢？答案是肯定的，比如<strong>应用程序端完全可以采用Skia等第三方的图形库，只要保持它们与SurfaceFlinger间的“协议”不变就可以了</strong>，如下所示：</p>
<p><img src="/img/android_graphic_system_05.png" alt=""></p>
<p>理论上来说，采用哪一种方式都是可行的。不过对于开发人员，特别是没有OpenGLES项目经验的人而言，前一种系统的门槛相对较高。事实上，Android系统同时提供了这两种实现来供上层选择。正常情况下我们按照SDK向导生成的apk应用，就属于后面的情况;而对于希望使用OpenGLES来完成复杂的界面渲染的应用开发者，也可以使用GLSurfaceView来达到目标。</p>
<p><img src="/img/android_graphic_system_06.png" alt=""><br>Canvas为在画布的意思。Android上层的作图几乎都通过Canvas实例来完成，其实Canvas更多是一种接口的包装。</p>
<h2 id="FramebufferNativeWindow（面向SurfaceFlinger）"><a href="#FramebufferNativeWindow（面向SurfaceFlinger）" class="headerlink" title="FramebufferNativeWindow（面向SurfaceFlinger）"></a>FramebufferNativeWindow（面向SurfaceFlinger）</h2><p>EGL创建一个Window Surface的函数原型列出如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  EGLNativeWindowType  NativeWindowType;<span class="comment">//注意这两种类型其实是一样的</span></span><br><span class="line"><span class="keyword">struct</span> ANativeWindow;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ANativeWindow*          EGLNativeWindowType;</span><br><span class="line"></span><br><span class="line"><span class="function">EGLSurface <span class="title">eglCreateWindowSurface</span><span class="params">(  EGLDisplay dpy, EGLConfig config,</span><br><span class="line">                          NativeWindowType  window, <span class="keyword">const</span> EGLint *attrib_list)</span></span>;</span><br></pre></td></tr></table></figure>
<p>表格 11‑2 不同平台下的EGLNativeWindowType<br>|操作系统|数据类型|<br>|——|——|<br>|Win32, WinCE|HWND，即句柄|<br>|Symbian|Void<em>|<br>|Android|ANativeWindow</em>          |<br>|Unix|Window|<br>|其它|暂时不支持|</p>
<p>在Android平台下，ANativeWindow指针类型就是OpenGL接口中的windows surface类型。</p>
<h3 id="ANativeWindow的定义"><a href="#ANativeWindow的定义" class="headerlink" title="ANativeWindow的定义"></a>ANativeWindow的定义</h3><p>ANativeWindow的定义在Window.h中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*system/core/include/system/Window.h*/</span></span><br><span class="line"><span class="keyword">struct</span> ANativeWindow</span><br><span class="line">&#123;…</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> flags; <span class="comment">//与Surface或updater有关的属性</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>   minSwapInterval;<span class="comment">//所支持的最小交换间隔时间</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>   maxSwapInterval;<span class="comment">//所支持的最大交换间隔时间</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> xdpi; <span class="comment">//水平方向的密度，以dpi为单位</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> ydpi;<span class="comment">//垂直方向的密度，以dpi为单位</span></span><br><span class="line">    <span class="keyword">intptr_t</span>    oem[<span class="number">4</span>];<span class="comment">//为OEM定制驱动所保留的空间</span></span><br><span class="line">    <span class="comment">//设置交换间隔时间，后面我们会讲解swap的作用</span></span><br><span class="line">    <span class="keyword">int</span>     (*setSwapInterval)(<span class="keyword">struct</span> ANativeWindow*window, <span class="keyword">int</span> interval);</span><br><span class="line">    <span class="comment">/*EGL通过这个接口来申请一个buffer。</span><br><span class="line">    以前面我们所举的例子来说，两个本地窗口所提供的buffer分别来自于帧缓冲区和内存空间。</span><br><span class="line">    单词“dequeue”的字面意思是“出队列”，这从侧面告诉我们，一个Window所包含的buffer很可能不只一份</span><br><span class="line">    */</span></span><br><span class="line">    <span class="keyword">int</span>     (*dequeueBuffer)(<span class="keyword">struct</span> ANativeWindow*window, <span class="keyword">struct</span> ANativeWindowBuffer** buffer);</span><br><span class="line">    <span class="comment">//申请到的buffer并没有被锁定，这种情况下是不允许我们去修改其中的内容的。所以我们必须要先调用lockBuffer来获得一个锁</span></span><br><span class="line">    <span class="keyword">int</span>     (*lockBuffer)(<span class="keyword">struct</span> ANativeWindow*window, <span class="keyword">struct</span> ANativeWindowBuffer* buffer);</span><br><span class="line">    <span class="comment">//当EGL对一块buffer渲染完成后，它调用这个接口来unlock和post buffer  </span></span><br><span class="line">    <span class="keyword">int</span>    (*queueBuffer)(<span class="keyword">struct</span> ANativeWindow* window, <span class="keyword">struct</span> ANativeWindowBuffer*buffer);</span><br><span class="line">    <span class="comment">//用于向本地窗口咨询相关信息</span></span><br><span class="line">    <span class="keyword">int</span>     (*query)(<span class="keyword">const</span> <span class="keyword">struct</span> ANativeWindow*window, <span class="keyword">int</span> what, <span class="keyword">int</span>* value);</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    用于执行本地窗口支持的各种操作，比如：</span><br><span class="line">	NATIVE_WINDOW_SET_USAGE</span><br><span class="line">	NATIVE_WINDOW_SET_CROP</span><br><span class="line">	NATIVE_WINDOW_SET_BUFFER_COUNT</span><br><span class="line">	NATIVE_WINDOW_SET_BUFFERS_TRANSFORM</span><br><span class="line">	NATIVE_WINDOW_SET_BUFFERS_TIMESTAMP</span><br><span class="line">    */</span></span><br><span class="line">    <span class="keyword">int</span>     (*perform)(<span class="keyword">struct</span> ANativeWindow* window,<span class="keyword">int</span> operation, ... );</span><br><span class="line">    <span class="comment">//这个接口可以用来取消一个已经dequeued的buffer，要特别注意同步的问题</span></span><br><span class="line">    <span class="keyword">int</span>     (*cancelBuffer)(<span class="keyword">struct</span> ANativeWindow*window, <span class="keyword">struct</span> ANativeWindowBuffer* buffer);</span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面对ANativeWindow的描述可以看出，它更像是一份“协议”，规定了一个本地窗口的形态和功能。这对于支持多种本地窗口的系统是必须的，因为只有这样子我们才能针对某种特定的平台窗口，来填充具体的实现。<br>FramebufferNativeWindow是如何履行这份“协议”的。</p>
<h3 id="FramebufferNativeWindow构造函数"><a href="#FramebufferNativeWindow构造函数" class="headerlink" title="FramebufferNativeWindow构造函数"></a>FramebufferNativeWindow构造函数</h3><p>基于FramebufferNativeWindow的功能，可以大概推测出它的构造函数里应该至少完成如下的初始化操作：</p>
<ul>
<li>加载GRALLOC_HARDWARE_MODULE_ID模块，详细流程我们在Gralloc小节已经解释过了</li>
<li>分别打开fb和gralloc设备。我们在Gralloc小节也已经分析过了，打开后的设备由全局变量fbDev和grDev管理</li>
<li>根据设备的属性来给FramebufferNativeWindow赋初值</li>
<li>根据FramebufferNativeWindow的实现来填充ANativeWindow中的“协议”</li>
<li>其它一些必要的初始化</li>
</ul>
<h3 id="dequeueBuffer"><a href="#dequeueBuffer" class="headerlink" title="dequeueBuffer"></a>dequeueBuffer</h3><p>。。。</p>
<h2 id="SurfaceTextureClient（面向应用）"><a href="#SurfaceTextureClient（面向应用）" class="headerlink" title="SurfaceTextureClient（面向应用）"></a>SurfaceTextureClient（面向应用）</h2><p>针对<strong>应用程序端的本地窗口</strong>是<strong>SurfaceTextureClient</strong>，和FramebufferNativeWindow一样，它必须继承ANativeWindow：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SurfaceTextureClient : <span class="keyword">public</span> ANativeObjectBase&lt;ANativeWindow, SurfaceTextureClient,RefBase&gt;</span><br></pre></td></tr></table></figure>
<p>SurfaceTextureClient的构造函数只是简单地调用了init函数，后者则对ANativeWindow::dequeueBuffer等函数指针及内部变量赋了初值。由于整个函数的功能很简单，我们只摘录其中的一部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/native/libs/gui/SurfaceTextureClient.cpp*/</span></span><br><span class="line"><span class="keyword">void</span> SurfaceTextureClient::init() &#123;</span><br><span class="line">    <span class="comment">/*给ANativeWindow中的函数指针赋值*/</span></span><br><span class="line">   ANativeWindow::setSwapInterval  =hook_setSwapInterval;</span><br><span class="line">    ANativeWindow::dequeueBuffer    = hook_dequeueBuffer;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">/*为各内部变量赋值，因为此时用户还没有真正发起申请，所以基本是0*/</span></span><br><span class="line">    mReqWidth = <span class="number">0</span>;</span><br><span class="line">    mReqHeight = <span class="number">0</span>;</span><br><span class="line">    …</span><br><span class="line">    mDefaultWidth = <span class="number">0</span>;</span><br><span class="line">    mDefaultHeight = <span class="number">0</span>;</span><br><span class="line">    mUserWidth = <span class="number">0</span>;</span><br><span class="line">    mUserHeight = <span class="number">0</span>;…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SurfaceTextureClient是面向Android系统中所有UI应用程序的，也就是说它承担着单个应用进程中的UI显示需求。基于这点考虑，可以推测出它的内部实现至少会有以下几点：</p>
<ul>
<li>提供给上层(主要是java层)绘制图像的“画板”<br>前面说过，这个本地窗口分配的内存应该不是来自于帧缓冲区，那么具体是由谁分配的，又是如何管理的呢？</li>
<li>它与SurfaceFlinger间是如何分工的?<br>显然SurfaceFlinger需要收集系统中所有应用程序绘制的图像数据，然后集中显示到物理屏幕上。在这个过程中，SurfaceTextureClient扮演了什么样的角色呢？</li>
</ul>
<p>SurfaceTextureClient只是一个中介，它间接调用mSurfaceTexture也就是ISurfaceTexture的服务。那么ISurfaceTexture在Server端又是由谁来完成的呢？</p>
<p><img src="/img/android_graphic_system_07.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过这两个小节，我们学习了显示系统中两个重要的本地窗口，即FramebufferNativewindow和SurfaceTextureClient。</p>
<ol>
<li>第一个窗口是专门为SurfaceFlinger服务的，它由Gralloc提供支持，相对逻辑上很好理解。</li>
<li>而SurfaceTextureClient则是为应用程序服务的，同时它从本质上还是由SurfaceFlinger服务统一管理的，因而涉及到很多跨进程的通信细节。</li>
</ol>
<p>这个小节我们只是简单地勾勒出其中的框架，接下去就要分几个方面来做完整的分析了。</p>
<ul>
<li><p>BufferQueue<br>为应用程序服务的本地窗口SurfaceTextureClient在server端的实现是BufferQueue。我们将详细解析BufferQueue的内部实现，并结合应用程序端的使用流程来理解清楚它们之间的关系。</p>
</li>
<li><p>Buffer、Consumer、Producer是“生产者-消费者”模型中的三个参与对象，如何协调好它们的工作是应用程序能否正常显示UI的关键。在接下来内容的安排上，我们先讲解Buffer(BufferQueue)与Producer(应用程序)间的交互，然后再专门切入Consumer(SurfaceFlinger)做详细分析</p>
</li>
</ul>
<h1 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h1><p>原文：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954803" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954803</a></p>
<p>BufferQueue，它是SurfaceTextureClient实现本地窗口的关键。从逻辑上来推断，BufferQueue应该是驻留在SurfaceFlinger这边的进程中。我们需要进一步解决的疑惑是：</p>
<ul>
<li>每个应用程序可以对应几个BufferQueue，它们是一对一、多对一或者是一对多？</li>
<li>应用程序所需要的绘图空间是由谁分配的？在音频系统的学习中，我们知道AudioTrack和AudioFlinger是通过共享内存的形式来进行数据传递的，那么显示系统中是否也是类似情况？</li>
<li>应用程序与SurfaceFlinger如何互斥共享数据区？和在Audio系统中遇到的问题一样，我们面临的是经典的“生产者-消费者”模型。显示系统又是如何协调好这两者间的互斥访问的呢？</li>
</ul>
<h2 id="BufferQueue的内部原理"><a href="#BufferQueue的内部原理" class="headerlink" title="BufferQueue的内部原理"></a>BufferQueue的内部原理</h2><p>因为BufferQueue是ISurfaceTexture的本地实现，所以它必须重载接口中的各虚函数，比如queueBuffer、requestBuffer、dequeueBuffer等等。</p>
<p><img src="/img/android_graphic_system_08.png" alt=""></p>
<p>另外，这个类的内部有一个非常重要的成员数组，即mSlots[NUM_BUFFER_SLOTS]，大家是否还记得前面SurfaceTextureClient类中也有一个一模一样的数组：</p>
<pre><code>class SurfaceTextureClient…{
                BufferSlot  mSlots[NUM_BUFFER_SLOTS];
</code></pre><p>数组的成员是BufferSlot，其中包含的GraphicBuffer变量(mGraphicBuffer)用于记录这个Slot所涉及的缓冲区，另外还有一个BufferState变量mBufferState用于跟踪每个缓冲区的状态，比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BufferState &#123;</span><br><span class="line">    FREE = <span class="number">0</span>, <span class="comment">/*Buffer当前可用，也就是说可以被dequeued。此时Buffer的owner</span><br><span class="line">               可认为是BufferQueue*/</span></span><br><span class="line">    DEQUEUED = <span class="number">1</span>, <span class="comment">/*Buffer已经被dequeued，还未被queued或canceld。此时</span><br><span class="line">                  Buffer的owner可认为是producer(应用程序)，这意味着server</span><br><span class="line">                  端(BufferQueue)不可以对这块缓冲区进行操作*/</span></span><br><span class="line">    QUEUED = <span class="number">2</span>, <span class="comment">/*Buffer已经被客户端queued，除特别情况外此时还不能对它进</span><br><span class="line">                  行dequeue，而可以acquired。此时的owner是BufferQueue*/</span></span><br><span class="line">    ACQUIRED = <span class="number">3</span><span class="comment">/*Buffer的owner改为consumer，可以released，</span><br><span class="line">                   然后状态又返回FREE*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Buffer状态迁移图如下：<br><img src="/img/android_graphic_system_09.png" alt=""></p>
<p>在这样的模型下，我们怎么保证Consumer可以及时的处理buffer呢？换句话说，当一块buffer数据ready后，应该怎么告知Consumer来操作呢？<br>仔细观察的话，可以看到BufferQueue里还同时提供了一个特别的类，名称为ConsumerListener，其中的函数接口包括：</p>
<pre><code>struct ConsumerListener :public virtual RefBase {       
    virtual void onFrameAvailable() = 0;/*当一块buffer可以被消费时，这个函数会被调用，特别注意此
                                    时没有共享锁的保护*/
    virtual void onBuffersReleased() = 0;/*BufferQueue通知consumer它已经释放其slot中的一个或多个
                                   GraphicBuffer引用*/
};
</code></pre><p> 这样子就很清楚了，当有一帧数据准备就绪后，BufferQueue就会调用<strong>onFrameAvailable</strong>()来通知Consumer进行消费。</p>
<h2 id="BufferQueue中的缓冲区分配"><a href="#BufferQueue中的缓冲区分配" class="headerlink" title="BufferQueue中的缓冲区分配"></a>BufferQueue中的缓冲区分配</h2><p>原文：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954834" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954834</a></p>
<p>当客户端 调用SurfaceTextureClient::dequeueBuffer()时，会导致SurfaceFlinger在BufferQueue中分配缓冲。</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>BufferQueue中有一个mSlots数组用于管理其内的各缓冲区，最大容量为32。从它的声明方式来看，这个mSlots在程序一开始就静态分配了32个BufferSlot大小的空间。不过这并不代表缓冲区也是一次性静态分配的，恰恰相反，从BufferSlot的内部变量指针mGraphicBuffer可以看出，<strong>缓冲区的空间分配应当是动态的</strong>(从下面的注释也能看出一些端倪)：</p>
<pre><code>// mGraphicBuffer points to the buffer allocated for this slot or isNULL if no buffer has been allocated.
       sp&lt;GraphicBuffer&gt; mGraphicBuffer;
</code></pre><p>缓冲区的分配在BufferQueue::dequeueBuffer()中进行。</p>
<pre><code>`status_t BufferQueue::dequeueBuffer(int *outBuf, uint32_t w,uint32_t h, uint32_t format, uint32_t usage)`
</code></pre><p>在该函数中，首先查找空闲的slot序号，但并不代表可用。当第一次使用该slot时，或者长宽高格式等信息不匹配时，其返回值中将加上标识BUFFER_NEEDS_REALLOCATION，表示需要分配内存。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>在客户端SurfaceTextureClient::dequeueBuffer()中的实现中可以发现：</p>
<ol>
<li>当mSurfaceTexture-&gt;dequeueBuffer()成功返回后，buf包含了mSlots中可用数组成员的序号。</li>
<li>如果结果中还发现BUFFER_NEEDS_REALLOCATION标志后，应该调用requestBuffer（）来分配内存。</li>
<li>然后，通过  <code>sp&lt;GraphicBuffer&gt;&amp; gbuf；*buffer = gbuf.get();</code> 来获取mSlots[buf]在本进程的地址。</li>
</ol>
<p>但一个很显然的问题是，既然客户端和BufferQueue运行于两个不同的进程中，那么它们两者中的mSlots[buf]会指向同一块物理内存吗？<br>SurfaceFlinger收到requestBuffer请求后，会实际分配内存，将其句柄handle通过binder的序列化接口传送到客户端。<br>通过handle句柄，Client端（应用）可以将指定的内存区域映射到自己的进程空间中，而这块区域与BufferQueue中所指向的物理空间是一致的，从而成功地实现了缓冲区的共享。handle它实际上是GraphicBuffer中打开的一个ashmem句柄，因而也就是两边进程共享缓冲区的关键。</p>
<h2 id="应用程序的典型绘图流程"><a href="#应用程序的典型绘图流程" class="headerlink" title="应用程序的典型绘图流程"></a>应用程序的典型绘图流程</h2><p>原文：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954840" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954840</a></p>
<p>应用程序并不会直接使用BufferQueue。和Android系统中很多其它地方一样，“层层包裹”在这里同样是存在的。</p>
<p>我们选取系统的开机动画这一应用程序，来分析整个图形绘制的流程。值得一提的是，这个开机动画的实现符合前面提到的两个改进的图形系统中的第一个，即应用程序与SurfaceFlinger都是使用OpenGL ES来完成UI显示，不过因为它是一个C++程序，所以不需要上层GLSurfaceView的支持。</p>
<p>这个开机动画的实现类是BootAnimation，它的内部就是借助SurfaceFlinger来完成的。</p>
<p>BootAnimation是一个C++程序，其工程源码路径是/frameworks/base/cmds/bootanimation。和很多native应用一样，它也是在init脚本中被启动的，大概来看下这一过程。</p>
<pre><code>service bootanim /system/bin/bootanimation
    class main
    user graphics
    group graphics
    disabled
    oneshot
</code></pre><p>当bootanimation被启动后，它首先会进入main函数，即main@Bootanimation_main.cpp，生成一个BootAnimation对象，并开启线程池(因为它需要与SurfaceFlinger等系统服务进行跨进程的通信)。在BootAnimation的构造函数中，同时生成一个SurfaceComposerClient：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BootAnimation::BootAnimation() : Thread(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    mSession = newSurfaceComposerClient();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ISurfaceTexture是应用程序与BufferQueue的传输通道，而ISurfaceComposerClient则是它与SurfaceFlinger间的桥梁。</strong></p>
<p>个人理解：ISurfaceTexture 封装对BufferQueue的访问，将绘制的内容放在缓冲区上。而ISurfaceComposerClient 负责告诉SurfaceFlinger这些缓冲区的元数据，以便SurfaceFlinger采用合适的参数对绘制缓冲（surface）做进一步的合成。</p>
<p>这样子的设计是合理的，体现了模块化的思想——SurfaceFlinger的职责是“Flinger”，即把系统中所有应用程序的最终的“绘图结果”进行“混合”，然后统一显示到物理屏幕上。它不应该，也没有办法分出太多的精力去一一关注各个应用程序的“绘画过程”。这个光荣的任务自然而然地落在了BufferQueue的肩膀上，它是每个应用程序“一对一”的辅导老师，指导着UI程序的“画板申请”、“作画流程”等一系列细节。下面的图描述了这三者的关系：</p>
<p><img src="/img/android_graphic_system_10.png" alt=""></p>
<p>的确是太乱了，我们有必要先来整理下目前已经出现的容易混淆的相关类的关系：</p>
<ul>
<li><strong>ISurfaceComposerClient</strong>: 应用程序与SurfaceFlinger间的通道，在应用进程中则被封装在SurfaceComposerClient这个类中。这是一个匿名binder server，由应用程序(具体位置在SurfaceComposerClient::onFirstRef中)调用SurfaceFlinger这个实名binder的createConnection方法来获取到，服务端的实现是SurfaceFlinger::Client。</li>
<li><strong>ISurface</strong>:由应用程序调用ISurfaceComposerClient::createSurface()得到，同时在SurfaceFlinger这一进程中将会有一个Layer被创建，代表了一个“画面”。ISurface就是控制这一画面的handle。</li>
<li><strong>Surface</strong>:从逻辑关系上看，它是上述<strong>ISurface</strong>的使用者。从继承关系上看，它是一个<strong>SurfaceTextureClient</strong>，也就是本地窗口。SurfaceTextureClient内部持有<strong>ISurfaceTexture</strong>，即<strong>BufferQueue</strong>的实现接口。换个角度来思考，当EGL想通过Surface这个native window完成某些功能时，后者实际上又利用ISurface和ISurfaceTexture来取得远程服务端的对应服务，以完成EGL的请求。</li>
<li><strong>Layer</strong>：既然Layer代表了一个画面图层，那么它肯定需要有存储图层数据的地方。当应用端通过ISurfaceComposerClient::createSurface()来发起创建Surface的请求时，SurfaceFlinger服务进程这边会创建一个Layer。</li>
</ul>
<p>一个典型的应用程序使用SurfaceFlinger进行绘图的流程如下图所示：<br><img src="/img/android_graphic_system_11.png" alt=""></p>
<p>各个class之间的关系式这样的：<br><img src="/img/android_graphic_system_12.png" alt=""></p>
<h2 id="应用程序与BufferQueue的关系"><a href="#应用程序与BufferQueue的关系" class="headerlink" title="应用程序与BufferQueue的关系"></a>应用程序与BufferQueue的关系</h2><p>原文：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954853" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954853</a></p>
<p>应用程序与BufferQueue的关系就比较明朗了。虽然中间经历了多次跨进程通信，但对于应用程序来说最终只使用到了BufferQueue(通过ISurfaceTexture)。从本小节的内容中，我们也可以从侧面证明如下几个关键点：</p>
<ol>
<li>应用程序可以调用createSurface来建立多个Layer，它们是一对多的关系。理由就是createSurface中没有任何机制来限制应用程序的多次调用，相反，它会把一个应用程序多次申请而产生的Layer统一管理。为应用程序申请的layer，一方面需要告知SurfaceFlinger，另一方面也要记录到各Client内部中，这两个步骤是由addClientLayer()分别调用Client::attachLayer()和SurfaceFlinger::addLayer_l()来完成的。对于SurfaceFlinger，它需要对系统中当前所有的Layer进行Z-order排序，以决定用户所能看到的“画面”是什么样的。对于Client，它则利用内部的mLayers成员变量来一一记录新增(attachLayer)和移除(detachLayer)的图层。</li>
<li>每个Layer对应一个BufferQueue，换句话说，一个应用程序可能对应多个BufferQueue。Layer没有直接持有BufferQueue，而是由其内部的mSurfaceTexture来管理。</li>
</ol>
<p><img src="/img/android_graphic_system_13.png" alt=""></p>
<p><img src="/img/android_graphic_system_14.png" alt=""></p>
<p>图 11‑19 应用程序与BufferQueue的对应关系</p>
<hr>
<h1 id="SurfaceFlinger"><a href="#SurfaceFlinger" class="headerlink" title="SurfaceFlinger"></a>SurfaceFlinger</h1><h2 id="Project-Butter黄油计划"><a href="#Project-Butter黄油计划" class="headerlink" title="Project Butter黄油计划"></a>Project Butter黄油计划</h2><p>原文：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954869" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954869</a></p>
<p>CPU、GPU负责渲染帧数据，Display负责屏幕的显示。<br>FPS（Frame peer Second） 代表CPU、GPU每秒能够渲染的桢数量。<br>刷新率 代表 显示设备的刷新率。<br>VSync(垂直同步)是VerticalSynchronization的简写，它利用VBI时期出现的vertical sync pulse来保证双缓冲在最佳时间点才进行交换。</p>
<p><img src="/img/android_graphic_system_15.png" alt=""><br>图 11‑22绘图过程没有采用VSync同步的情况</p>
<p><img src="/img/android_graphic_system_16.png" alt=""><br>图 11‑25 FPS低于屏幕刷新率的情况</p>
<p>当CPU/GPU的处理时间超过16ms时，第一个VSync到来时，缓冲区B中的数据还没有准备好，于是只能继续显示之前A缓冲区中的内容。而B完成后，又因为缺乏VSync pulse信号，它只能等待下一个signal的来临。于是在这一过程中，有一大段时间是被浪费的。当下一个VSync出现时，CPU/GPU马上执行操作，此时它可操作的buffer是A，相应的显示屏对应的就是B。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”。</p>
<p>为了避免tear，当FPS &gt; 刷新率时，采用双缓冲技术。当收到VSync，CPU/GPU立即开始准备新的frame；而Display则显示之间已经准备好的frame。<br>当FPS &lt; 刷新率时，采用三缓冲技术，保证frame准备好能够尽快显示。这时候如果采用双缓冲，准备好的帧可能需要等待近一个VSync周期才能显示。</p>
<h2 id="SurfaceFlinger的启动与工作原理"><a href="#SurfaceFlinger的启动与工作原理" class="headerlink" title="SurfaceFlinger的启动与工作原理"></a>SurfaceFlinger的启动与工作原理</h2><p>原文：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954951" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954951</a></p>
<h2 id="SurfaceComposerClient"><a href="#SurfaceComposerClient" class="headerlink" title="SurfaceComposerClient"></a>SurfaceComposerClient</h2><p>原文：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954957" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954957</a></p>
<p><img src="/img/android_graphic_system_17.png" alt=""><br>图 11‑28 每个应用程序在SurfaceFlinger中都对应一个Client</p>
<p>SurfaceFlinger运行于SystemServer这一系统进程中，需要UI界面显示的应用程序则通过binder服务与它进行跨进程通信。在音频系统的学习中，每一个AudioTrack在AudioFlinger中都可以找到一个对应的Track实现。这种设计方式同样适用于显示系统，即任何有UI界面的程序都在SurfaceFlinger中有且仅有一个Client实例。</p>
<p>应用程序与SurfaceFlinger间的接口是<strong>ISurfaceComposerClient</strong>，<strong>Client</strong>的父类是BnSurfaceComposerClient,它是这一接口的本地端实现。</p>
<p>ISurfaceComposerClient接口中最重要的两个方法createSurface()和destroySurface()分别用于向SurfaceFlinger申请和销毁一个ISurface。<strong>那么既然有了Client，为什么还要再引出另一个binder对象呢？</strong></p>
<p>这是因为每个SurfaceFlinger的<strong>客户程序</strong>都只会有唯一一个Client连接，但它们<strong>内部拥有的Surface数量却很可能有多个</strong>。通常情况下，同一个Activity中的UI布局共用系统分配的Surface进行绘图，但像SurfaceView这种UI组件就是特例——它独占一个Surface进行绘制。举个例子来说，如果我们制作一个带SurfaceView的视频播放器，其所在的应用程序最终就会有不止一个的Surface存在。这样设计是必须的，因为播放视频对刷新频率要求很高，采用单独的Surface既可以保证视频的流畅度，也同时能让用户的交互动作(比如触摸屏操作)及时得到响应。</p>
<p><img src="/img/android_graphic_system_18.png" alt=""></p>
<h1 id="VSync"><a href="#VSync" class="headerlink" title="VSync"></a>VSync</h1><p>原文：<a href="http://blog.csdn.net/xuesen_lin/article/details/8954986" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8954986</a></p>
<p>Android 4.1显示系统中的新特性，其中一个就是加入了VSync同步。<br>VSync信号是如何产生的呢？<br>在Android源码surfaceflinger目录下有一个displayhardware文件夹，其中HWComposer的主要职责之一，就是用于产生VSync信号。<strong>VSync信号源 可以是硬件的，也可以是软件模拟的</strong>。<br>分析HWComposer::HWComposer（…）,假如当前系统可以成功加载HWC_HARDWARE_MODULE_ID=“hwcomposer”，并且通过这个库模块能顺利打开设备(hwc_composer_device_t)，其版本号又大于HWC_DEVICE_API_VERSION_0_3的话，我们就采用“<strong>硬件源</strong>”(此时needVSyncThread为false)，否则需要创建一个新的VSync线程来模拟产生信号。</p>
<h2 id="VSync信号的产生和分发"><a href="#VSync信号的产生和分发" class="headerlink" title="VSync信号的产生和分发"></a>VSync信号的产生和分发</h2><h2 id="VSync信号的处理"><a href="#VSync信号的处理" class="headerlink" title="VSync信号的处理."></a>VSync信号的处理.</h2><p><a href="http://blog.csdn.net/xuesen_lin/article/details/8955012" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8955012</a></p>
<p>现在SurfaceFlinger只处理REFRESH一个消息，其主要工作是：</p>
<ul>
<li>handleTransaction<br>即处理事务，什么样的事务呢？在SurfaceFlinger::setTransactionState()中我们可以看到，假如当前的orientation和新的不符合时，会将eTransactionNeeded置位;当应用程序请求createSurface、removeSurface，或者addLayer、removeLayer时也会把它置位。另一个flag被置位的情况则包括：layer的size、alpha、matrix、transparentregion、visibility变化等等。<br>总结起来，就是当与系统显示相关的状态(比如新增/减少了Surface，显示屏的变化等等)改变，或者某个Layer自身状态(比如它的大小尺寸、可见性、透明度等等)改变时，就需要执行Transaction。</li>
<li>handlePageFlip<br>由前面的分析我们知道，每个Layer对应着最多32个BufferSlot，这样系统在进行一次刷新时，必须先决定使用哪个buffer，并利用这一缓冲区更新纹理。另外，我们还需要计算所有图层的可见区域和“脏区域”，以便最终的合成显示。</li>
<li>handleRefresh<br>版本更新遗留下的函数，当前实现中没有起到作用，相信在后续升级中会进一步完善。</li>
<li>handleWorkList<br>创建HWComposer中的mList，这个列表将用于后续的layer合成。这个函数比较简单，我们不单独介绍。</li>
<li>handleRepaint<br>计算出最终的脏区域，并执行实际的合成工作(composeSurfaces)，我们将做详细源码分析。</li>
<li>postFramebuffer<br>将上一步中生成的缓冲区数据post到framebuffer中，这样才能真正在物理屏幕上显示出来。分为两条路径，即HWComposer::commit和直接调用eglSwapBuffers()</li>
</ul>
<h2 id="handleTransaction"><a href="#handleTransaction" class="headerlink" title="handleTransaction"></a>handleTransaction</h2><p><a href="http://blog.csdn.net/xuesen_lin/article/details/8955121" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8955121</a></p>
<h2 id="handlePageFlip"><a href="#handlePageFlip" class="headerlink" title="handlePageFlip"></a>handlePageFlip</h2><p><a href="http://blog.csdn.net/xuesen_lin/article/details/8955138" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8955138</a></p>
<h2 id="handleRefresh"><a href="#handleRefresh" class="headerlink" title="handleRefresh"></a>handleRefresh</h2><p><a href="http://blog.csdn.net/xuesen_lin/article/details/8955173" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8955173</a></p>
<h2 id="handleRepaint"><a href="#handleRepaint" class="headerlink" title="handleRepaint"></a>handleRepaint</h2><p><a href="http://blog.csdn.net/xuesen_lin/article/details/8955183" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8955183</a></p>
<h2 id="postFramebuffer"><a href="#postFramebuffer" class="headerlink" title="postFramebuffer"></a>postFramebuffer</h2><p><a href="http://blog.csdn.net/xuesen_lin/article/details/8955198" target="_blank" rel="external">http://blog.csdn.net/xuesen_lin/article/details/8955198</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://blog.andjoin.com/2015/07/01/Android/android_graphic_system/" data-id="ciqd33ser0003l803eko46qf0" class="article-share-link" data-share="baidu" data-title="[摘]Android 图形系统 （Android 4.3）">Share</a>
      

      
        <a href="http://blog.andjoin.com/2015/07/01/Android/android_graphic_system/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/framework/">framework</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/graphic/">graphic</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/02/26/Security/SETools/setools4_sedta/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          setools4 sedta 转换图的构建分析
        
      </div>
    </a>
  
  
    <a href="/2015/06/30/Android/adb service out of date/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">如何解决adb过时问题：adb service out of date</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="2015/07/01/Android/android_graphic_system/" data-title="[摘]Android 图形系统 （Android 4.3）" data-url="http://blog.andjoin.com/2015/07/01/Android/android_graphic_system/"></div>
  </section>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/OpenCourse/">OpenCourse</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">security</a><span class="category-list-count">13</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BYOD/">BYOD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BigData/">BigData</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LSM/">LSM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Log/">Log</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Security-SELinux/">SELinux</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/adb/">adb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c++</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/capabilities/">capabilities</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/crypt/">crypt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/framework/">framework</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/graphic/">graphic</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/howto/">howto</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iptable/">iptable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/">security</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/selinux/">selinux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sepolicy/">sepolicy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/setools/">setools</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/setools4/">setools4</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BYOD/" style="font-size: 10px;">BYOD</a> <a href="/tags/BigData/" style="font-size: 10px;">BigData</a> <a href="/tags/LSM/" style="font-size: 10px;">LSM</a> <a href="/tags/Log/" style="font-size: 10px;">Log</a> <a href="/tags/Security-SELinux/" style="font-size: 20px;">SELinux</a> <a href="/tags/adb/" style="font-size: 10px;">adb</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/c/" style="font-size: 10px;">c++</a> <a href="/tags/capabilities/" style="font-size: 10px;">capabilities</a> <a href="/tags/crypt/" style="font-size: 10px;">crypt</a> <a href="/tags/framework/" style="font-size: 10px;">framework</a> <a href="/tags/graphic/" style="font-size: 10px;">graphic</a> <a href="/tags/howto/" style="font-size: 13.33px;">howto</a> <a href="/tags/iptable/" style="font-size: 10px;">iptable</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/security/" style="font-size: 16.67px;">security</a> <a href="/tags/selinux/" style="font-size: 10px;">selinux</a> <a href="/tags/sepolicy/" style="font-size: 10px;">sepolicy</a> <a href="/tags/setools/" style="font-size: 10px;">setools</a> <a href="/tags/setools4/" style="font-size: 10px;">setools4</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/08/Security/SETools/sepolicy_HWRNG/">为什么不容许应用访问HWRNG(硬件随机数产生器)设备?</a>
          </li>
        
          <li>
            <a href="/2016/06/29/Security/SELinux/selinux_howto_create_data_dir_for_app/">SELinux: 如何为进程创建专有的数据目录？</a>
          </li>
        
          <li>
            <a href="/2016/06/23/Security/introduction-information-security/">信息安全管理介绍</a>
          </li>
        
          <li>
            <a href="/2016/06/23/Security/SELinux/selinux_implement_as_LSM/">SELinux 基于LSM的实现</a>
          </li>
        
          <li>
            <a href="/2016/06/23/Program/algorithm_name_match/">人名匹配问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://github.com" target="_blank">github</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 LargeRiver<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="totop"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"largeriver"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js"></script>

</div>
</body>
</html>
